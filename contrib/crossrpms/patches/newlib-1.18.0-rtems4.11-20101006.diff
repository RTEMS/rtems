diff -Naur newlib-1.18.0.orig/newlib/ChangeLog.rtems newlib-1.18.0/newlib/ChangeLog.rtems
--- newlib-1.18.0.orig/newlib/ChangeLog.rtems	1970-01-01 01:00:00.000000000 +0100
+++ newlib-1.18.0/newlib/ChangeLog.rtems	2010-10-06 05:19:06.439315613 +0200
@@ -0,0 +1,258 @@
+2010-10-05  Eric Blake  <eblake@redhat.com>
+
+	memmem, strstr, strcasestr: fix bug with long periodic needle
+    	* lib/str-two-way.h (two_way_long_needle): Avoid bug with long
+	periodic needle having false positive.
+
+2010-09-21  Craig Howland <howland@LGSInnovations.com>
+
+	* libc/string/memcpy.c: Do not assign size_t parameter to int.
+	Use parameter directly, instead.
+	* libc/string/memccpy.c:  Likewise.
+	* libc/string/mempcpy.c:  Likewise.
+	* libc/string/memmove.c:  Likewise.
+
+2010-09-04  	Joel Sherrill <joel@OARcorp.com>
+
+	* include/pthread.h: Add pthread_attr_setstack, pthread_attr_getstack,
+	pthread_attr_getguardsize, pthread_attr_setguardsize.
+	* sys/types.h (pthread_attr_t): Add guardsize.
+
+2010-08-24  Sebastian Huber <sebastian.huber@embedded-brains.de>
+
+	* libc/posix/opendir.c: Added missing memory free.
+
+2010-08-10	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	PR 1475/newlib:
+	* libc/include/stdint.h: Fall back to compute SIZE_MAX based on
+	__SIZEOF_SIZE_T__ and __CHAR_BIT__ if available.
+
+2010-08-04	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/string/strcat.c: 
+	Include <stdint.h>. Use uintptr_t instead of long in ALIGNED.
+	* libc/string/strchr.c, libc/string/strcmp.c, libc/string/strncmp.c:
+	Include <stdint.h>. Use uintptr_t instead of long in UNALIGNED.
+	* libc/include/sys/unistd.h: Activate decls for 
+	getsid, setegid, seteuid.
+
+2010-07-08	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* configure.host: Add -D_COMPILING_NEWLIB to newlib_cflags.
+	* libc/string/index.c, libc/string/rindex.c: Include <string.h>.
+	* libc/stdlib/putenv_r.c: Include <strings.h>
+
+2010-07-06  Corinna Vinschen  <corinna@vinschen.de>
+
+	* libc/posix/rewinddir.c (rewinddir): Remove incorrect cast to off_t.
+	* libc/sys/rtems/sys/dirent.h (_seekdir): Add prototype.
+	* libc/sys/linux/sys/dirent.h (_seekdir): Fix prototype to use long
+	rather than off_t.
+
+2010-06-17	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/_types.h: Special case for sparc64.
+
+2010-04-23	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/_types.h: Add _mode_t.
+	* libc/include/sys/types.h: Derive mode_t from  _mode_t.
+
+2010-04-02	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/sched.h, libc/include/sys/sched.h:
+	Adopt newlib-cvs's versions.
+
+2010-03-25	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/strings.h: New (split-out from string.h).
+	* libc/include/string.h: Remove bcmp, bcopy, bzero, ffs, index, rindex,
+	strcasecmp, strncasecmp (Moved to strings.h).
+	Remove strcmpi, stricmp, strncmpi, strnicmp.
+	* libc/misc/ffs.c: Use <strings.h> instead of <string.h>.
+	* libc/string/bcmp.c: Use <strings.h> instead of <string.h>.
+	* libc/string/bzero.c: Use <strings.h> instead of <string.h>.
+	* libc/string/rindex.c: Use <strings.h> instead of <string.h>.
+	* libc/string/strcasecmp.c: Use <strings.h> instead of <string.h>.
+	* libc/string/strcasecmp.c: Use <strings.h> instead of <string.h>.
+
+2010-03-23	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/_types.h: Add i386 to 64bit off_t targets.
+
+2010-03-10	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/posix/telldir.c: Adopt newlib-cvs's telldir.c
+
+2010-02-10	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/_types.h: Use __int64_t for _off_t, fpos_t for 
+	selected targets.
+
+2010-02-05	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/posix/telldir.c: Remove bogus nested prototype of lseek().
+
+2010-01-11  Sebastian Huber <sebastian.huber@embedded-brains.de>
+
+	* libc/posix/telldir.c (_cleanupdir): Fixed usage of freed memory.
+
+2009-12-18	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/search/db_local.h:
+	Use __uint32_t instead of u_int (prototype mismatches).
+	* libc/search/extern.h (__buf_init): 
+	Use __uint32_t instead of int (16 bit target portability).
+	* libc/search/hash_buf.c: Use ptrdiff_t instead of __uint32_t,
+	use __uint32_t instead of int (16 bit target portability).
+	* libc/search/hash.h: Use __uint32_it instead of int
+	(16 bit target portability).
+	* libm/common/modfl.c: Add cast to (double*) to avoid GCC warning.
+	* libm/common/sf_llrint.c, libm/common/sf_round.c: Add explicit 
+	casts to __uint32_t to avoid overflows on implicit casts.
+
+2009-12-18	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	Merger with newlib-1.18.0.
+
+2009-10-29	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/_types.h: Rework.
+	* libc/sys/rtems/machine/stdint.h: Remove.
+	* libc/include/inttypes.h: 
+	Rework logic to determine PRI*PTR.
+	Prefer long64 over longlong64.
+	* libc/include/machine/_default_types.h: 
+	Sync logic for __int32 with stdint.h (Prefer long over int).
+	* libc/include/stdint.h:
+	Remove __SPU__ hack.
+	Prefer int for int16_t (sync with _default_types.h).
+	Rework intptr_t determination.
+
+2009-10-28	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/_types.h: New.
+	Add custom time for _ssize_t.
+	* libc/stdlib/assert.c: Sync with newlib-CVS.
+	* configure.host: Add -DHAVE_ASSERT_FUNC to newlib_cflags.
+
+2009-10-27	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/sys/pthread.h: 
+	Add pthread_atfork (Mandated by IEEE Std 1003.1-2008).
+	Add pthread_rwlock_unlock (Formerly missing)
+
+2009-10-26	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/sys/signal.h: Sync with newlib-CVS.
+
+2009-10-09	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/sys/signal.h: Use pid_t as 1st arg to kill()
+	(mandated by POSIX).
+
+2009-09-22	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/sys/queue.h: Update copyright (from FreeBSD).
+	Remove CIRCLEQ_*.
+	* libc/search/hcreate.c: Don't include sys/queue.h.
+
+2009-09-18  Christopher Faylor  <me+cygwin@cgf.cx>
+
+	* libc/include/sys/unistd.h: Declare getpagesize as returning
+	POSIX-mandated int.
+
+2009-09-16	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/crt0.c: Use while(1) in _exit stub to silence GCC "noreturn"
+	warning.
+
+2009-09-15	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/stdlib.h: Add posix_memalign.
+
+2009-09-11	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* configure.host (m32c): Remove -D_ABORT_PROVIDED.
+
+2009-09-10	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* configure.host: Add -D_NO_POPEN.
+	* libc/sys/rtems/crt0.c: Don't provide waitpid unless used.
+
+2009-09-09	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* configure.host: Add -D_NO_WORDEXP.
+
+2009-09-06	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/crt0.c: Add issetugid.
+
+2009-09-02	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/crt0.c: Rework. Introduce macro RTEMS_STUB.
+
+2009-07-27	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/crt0.c: Add _isatty_r.
+
+2009-07-06	Joel Sherrill <joel.sherrill@oarcorp.com>
+
+	* libc/include/sys/features.h: Define _UNIX98_THREAD_MUTEX_ATTRIBUTES.
+
+2009-05-05	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* configure.host: Remove -DMISSING_SYSCALL_NAMES.
+
+2009-03-11	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/stdlib/assert.c: Don't build __assert_func.
+	* libc/sys/rtems/crt0.c: Add __assert_func.
+
+2009-03-09	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/machine/powerpc/times.c: Remove.
+	* libc/machine/powerpc/Makefile.am: Remove times.c.
+	* libc/machine/powerpc/Makefile.in: Regenerate.
+
+2009-02-24	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/unix/ttyname.c: Sync with newlib-cvs.
+	* configure.host: Add -DHAVE_BLKSIZE to newlib_cflags.
+
+2009-02-22	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/machine/stdint.h: Add __lm32__.
+	* libc/machine/lm32/configure.in: Set AC_CONFIG_SRC to setjmp.S.
+	* libc/machine/lm32/configure: Regenerate.
+
+2009-02-20	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/unix/Makefile.in: Regenerate.
+
+2009-02-20  Craig Howland <howland@LGSInnovations.com> on behalf of
+	Sebastian Huber <sebastian.huber@embedded-brains.de>
+
+	* libc/unix/ttyname.c:  Remove ttyname_r() (to a new file to avoid
+	coupling ttyname_r() and ttyname() due to the latter's large buffer).
+	* libc/unix/ttyname_r.c:  New file to hold ttyname_r(), previously in
+	ttyname.c.
+	* libc/unix/ttyname.h:  New file (common size definition for the 2
+	ttyname*c files that are now split).
+	* libc/unix/Makefile.am (ELIX_2_SOURCES):  Add ttyname_r.c.
+
+2009-02-16	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/sys/rtems/sys/param.h:
+	Update copyright notice from FreeBSD.
+	Remove HZ.
+	Add #include <sys/priority.h>
+	Remove priority handling (moved to sys/priority.h).
+	Remove CLBYTES (Unused, abandoned in BSD).
+
+2009-02-06	Ralf Corsépius <ralf.corsepius@rtems.org>
+
+	* libc/include/sched.h:
+	Remove (collides with RTEMS's schedul.h).
+
diff -Naur newlib-1.18.0.orig/newlib/configure.host newlib-1.18.0/newlib/configure.host
--- newlib-1.18.0.orig/newlib/configure.host	2009-12-10 18:12:11.000000000 +0100
+++ newlib-1.18.0/newlib/configure.host	2010-09-22 06:41:42.989786386 +0200
@@ -556,6 +556,7 @@
   *-*-rtems*)
 	default_newlib_io_long_long="yes"
 	default_newlib_io_c99_formats="yes"
+	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB"
 	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DEXIT_PROVIDED -DSIGNAL_PROVIDED -DREENTRANT_SYSCALLS_PROVIDED -DHAVE_NANOSLEEP -DHAVE_BLKSIZE -DHAVE_FCNTL -DHAVE_ASSERT_FUNC"
         # turn off unsupported items in posix directory 
 	newlib_cflags="${newlib_cflags} -D_NO_GETLOGIN -D_NO_GETPWENT -D_NO_GETUT -D_NO_GETPASS -D_NO_SIGSET -D_NO_WORDEXP -D_NO_POPEN"
diff -Naur newlib-1.18.0.orig/newlib/libc/include/inttypes.h newlib-1.18.0/newlib/libc/include/inttypes.h
--- newlib-1.18.0.orig/newlib/libc/include/inttypes.h	2009-01-19 23:02:06.000000000 +0100
+++ newlib-1.18.0/newlib/libc/include/inttypes.h	2010-09-22 06:41:42.990911271 +0200
@@ -242,6 +242,20 @@
 #define SCNxMAX		__SCNMAX(x)
 
 /* ptr types */
+#if INTPTR_MAX == INT64_MAX
+#define __PRIPTR(x) __PRI64(x)
+#define __SCNPTR(x) __SCN64(x)
+#elif INTPTR_MAX == INT32_MAX
+#define __PRIPTR(x) __PRI32(x)
+#define __SCNPTR(x) __SCN32(x)
+#elif INTPTR_MAX == INT16_MAX
+#define __PRIPTR(x) __PRI16(x)
+#define __SCNPTR(x) __SCN16(x)
+#else
+#error cannot determine PRI*PTR
+#endif
+
+#if 0
 #if __have_long64
 #define __PRIPTR(x) __STRINGIFY(l##x)
 #define __SCNPTR(x) __STRINGIFY(l##x)
@@ -252,6 +266,7 @@
 #define __PRIPTR(x) __STRINGIFY(x)
 #define __SCNPTR(x) __STRINGIFY(x)
 #endif
+#endif
 
 #define PRIdPTR		__PRIPTR(d)
 #define PRIiPTR		__PRIPTR(i)
diff -Naur newlib-1.18.0.orig/newlib/libc/include/machine/_default_types.h newlib-1.18.0/newlib/libc/include/machine/_default_types.h
--- newlib-1.18.0.orig/newlib/libc/include/machine/_default_types.h	2008-06-12 00:14:54.000000000 +0200
+++ newlib-1.18.0/newlib/libc/include/machine/_default_types.h	2010-09-22 06:41:42.990911271 +0200
@@ -54,14 +54,14 @@
 #endif
 #endif
 
-#if __EXP(INT_MAX) == 0x7fffffffL
-typedef signed int __int32_t;
-typedef unsigned int __uint32_t;
-#define ___int32_t_defined 1
-#elif __EXP(LONG_MAX) == 0x7fffffffL
+#if __EXP(LONG_MAX) == 0x7fffffffL
 typedef signed long __int32_t;
 typedef unsigned long __uint32_t;
 #define ___int32_t_defined 1
+#elif __EXP(INT_MAX) == 0x7fffffffL
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#define ___int32_t_defined 1
 #elif __EXP(SHRT_MAX) == 0x7fffffffL
 typedef signed short __int32_t;
 typedef unsigned short __uint32_t;
diff -Naur newlib-1.18.0.orig/newlib/libc/include/pthread.h newlib-1.18.0/newlib/libc/include/pthread.h
--- newlib-1.18.0.orig/newlib/libc/include/pthread.h	2009-12-17 20:22:23.000000000 +0100
+++ newlib-1.18.0/newlib/libc/include/pthread.h	2010-10-04 09:23:34.964316973 +0200
@@ -2,7 +2,7 @@
  *
  *  Written by Joel Sherrill <joel@OARcorp.com>.
  *
- *  COPYRIGHT (c) 1989-2000.
+ *  COPYRIGHT (c) 1989-2010.
  *  On-Line Applications Research Corporation (OAR).
  *
  *  Permission to use, copy, modify, and distribute this software for any
@@ -185,10 +185,14 @@
 
 int	_EXFUN(pthread_attr_init, (pthread_attr_t *__attr));
 int	_EXFUN(pthread_attr_destroy, (pthread_attr_t *__attr));
+int	_EXFUN(pthread_attr_setstack, (pthread_attr_t *attr,
+	void *__stackaddr, size_t __stacksize));
+int	_EXFUN(pthread_attr_getstack, (_CONST pthread_attr_t *attr,
+	void **__stackaddr, size_t *__stacksize));
 int	_EXFUN(pthread_attr_getstacksize,
 	(_CONST pthread_attr_t *__attr, size_t *__stacksize));
 int	_EXFUN(pthread_attr_setstacksize,
-	(pthread_attr_t *__attr, size_t stacksize));
+	(pthread_attr_t *__attr, size_t __stacksize));
 int	_EXFUN(pthread_attr_getstackaddr,
 	(_CONST pthread_attr_t *__attr, void **__stackaddr));
 int	_EXFUN(pthread_attr_setstackaddr,
@@ -197,6 +201,10 @@
 	(_CONST pthread_attr_t *__attr, int *__detachstate));
 int	_EXFUN(pthread_attr_setdetachstate,
 	(pthread_attr_t *__attr, int __detachstate));
+int	_EXFUN(pthread_attr_getguardsize,
+	(_CONST pthread_attr_t *__attr, size_t *__guardsize));
+int	_EXFUN(pthread_attr_setguardsize,
+	(pthread_attr_t *__attr, size_t __guardsize));
 
 /* Thread Creation, P1003.1c/Draft 10, p. 144 */
 
diff -Naur newlib-1.18.0.orig/newlib/libc/include/sched.h newlib-1.18.0/newlib/libc/include/sched.h
--- newlib-1.18.0.orig/newlib/libc/include/sched.h	2007-09-21 23:02:15.000000000 +0200
+++ newlib-1.18.0/newlib/libc/include/sched.h	2010-09-22 06:41:42.990911271 +0200
@@ -1,11 +1,94 @@
+/*
+ *  Written by Joel Sherrill <joel@OARcorp.com>.
+ *
+ *  COPYRIGHT (c) 1989-2010.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  Permission to use, copy, modify, and distribute this software for any
+ *  purpose without fee is hereby granted, provided that this entire notice
+ *  is included in all copies of any software which is or includes a copy
+ *  or modification of this software.
+ *
+ *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+ *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
+ *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
+ *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ *  $Id$
+ */
+
 #ifndef _SCHED_H_
 #define _SCHED_H_
 
+#include <sys/types.h>
+#include <sys/sched.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <sys/sched.h>
+#if defined(_POSIX_PRIORITY_SCHEDULING)
+/*
+ *  XBD 13 - Set Scheduling Parameters, P1003.1b-2008, p. 1803
+ */
+int sched_setparam(
+  pid_t                     __pid,
+  const struct sched_param *__param
+);
+
+/*
+ *  XBD 13 - Set Scheduling Parameters, P1003.1b-2008, p. 1800
+ */
+int sched_getparam(
+  pid_t                     __pid,
+  struct sched_param       *__param
+);
+
+/*
+ *  XBD 13 - Set Scheduling Policy and Scheduling Parameters,
+ *         P1003.1b-2008, p. 1805
+ */
+int sched_setscheduler(
+  pid_t                     __pid,
+  int                       __policy,
+  const struct sched_param *__param
+);
+
+/*
+ *  XBD 13 - Get Scheduling Policy, P1003.1b-2008, p. 1801
+ */
+int sched_getscheduler(
+  pid_t                     __pid
+);
+
+/*
+ *  XBD 13 - Get Scheduling Parameter Limits, P1003.1b-2008, p. 1799
+ */
+int sched_get_priority_max(
+  int __policy
+);
+
+int sched_get_priority_min(
+  int  __policy
+);
+
+/*
+ *  XBD 13 - Get Scheduling Parameter Limits, P1003.1b-2008, p. 1802
+ */
+int sched_rr_get_interval(
+  pid_t             __pid,
+  struct timespec  *__interval
+);
+#endif /* _POSIX_PRIORITY_SCHEDULING */
+
+#if defined(_POSIX_THREADS) || defined(_POSIX_PRIORITY_SCHEDULING)
+
+/*
+ *  XBD 13 - Yield Processor, P1003.1b-2008, p. 1807
+ */
+int sched_yield( void );
+
+#endif /* _POSIX_THREADS or _POSIX_PRIORITY_SCHEDULING */
 
 #ifdef __cplusplus
 }
diff -Naur newlib-1.18.0.orig/newlib/libc/include/stdint.h newlib-1.18.0/newlib/libc/include/stdint.h
--- newlib-1.18.0.orig/newlib/libc/include/stdint.h	2009-04-24 23:55:07.000000000 +0200
+++ newlib-1.18.0/newlib/libc/include/stdint.h	2010-09-22 06:41:42.990911271 +0200
@@ -33,7 +33,7 @@
 /* Check if "long" is 64bit or 32bit wide */
 #if __STDINT_EXP(LONG_MAX) > 0x7fffffff
 #define __have_long64 1
-#elif __STDINT_EXP(LONG_MAX) == 0x7fffffff && !defined(__SPU__)
+#elif __STDINT_EXP(LONG_MAX) == 0x7fffffff
 #define __have_long32 1
 #endif
 
@@ -49,14 +49,14 @@
 #define __int_least8_t_defined 1
 #endif
 
-#if __STDINT_EXP(SHRT_MAX) == 0x7fff
-typedef signed short int16_t;
-typedef unsigned short uint16_t;
-#define __int16_t_defined 1
-#elif __STDINT_EXP(INT_MAX) == 0x7fff
+#if __STDINT_EXP(INT_MAX) == 0x7fff
 typedef signed int int16_t;
 typedef unsigned int uint16_t;
 #define __int16_t_defined 1
+#elif __STDINT_EXP(SHRT_MAX) == 0x7fff
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+#define __int16_t_defined 1
 #elif __STDINT_EXP(SCHAR_MAX) == 0x7fff
 typedef signed char int16_t;
 typedef unsigned char uint16_t;
@@ -239,6 +239,29 @@
  * GCC doesn't provide an appropriate macro for [u]intptr_t
  * For now, use __PTRDIFF_TYPE__
  */
+#if defined(__SIZEOF_POINTER__)
+#if __SIZEOF_POINTER__ == 8
+  typedef int64_t intptr_t;
+  typedef uint64_t uintptr_t;
+#define INTPTR_MAX INT64_MAX
+#define INTPTR_MIN INT64_MIN
+#define UINTPTR_MAX UINT64_MAX
+#elif __SIZEOF_POINTER__ == 4
+  typedef int32_t intptr_t;
+  typedef uint32_t uintptr_t;
+#define INTPTR_MAX INT32_MAX
+#define INTPTR_MIN INT32_MIN
+#define UINTPTR_MAX UINT32_MAX
+#elif __SIZEOF_POINTER__ == 2
+  typedef int16_t intptr_t;
+  typedef uint16_t uintptr_t;
+#define INTPTR_MAX INT16_MAX
+#define INTPTR_MIN INT16_MIN
+#define UINTPTR_MAX UINT16_MAX
+#else
+#error cannot determine intptr_t
+#endif
+#else
 #if defined(__PTRDIFF_TYPE__)
 typedef signed __PTRDIFF_TYPE__ intptr_t;
 typedef unsigned __PTRDIFF_TYPE__ uintptr_t;
@@ -260,6 +283,7 @@
 #define INTPTR_MIN (-__STDINT_EXP(LONG_MAX) - 1)
 #define UINTPTR_MAX (__STDINT_EXP(LONG_MAX) * 2UL + 1)
 #endif
+#endif
 
 /* Limits of Specified-Width Integer Types */
 
@@ -408,6 +432,8 @@
 /* This must match size_t in stddef.h, currently long unsigned int */
 #ifdef __SIZE_MAX__
 #define SIZE_MAX __SIZE_MAX__
+#elif defined(__SIZEOF_SIZE_T__) && defined(__CHAR_BIT__)
+#define SIZE_MAX (__SIZEOF_SIZE_T__ * __CHAR_BIT__)
 #else
 #define SIZE_MAX (__STDINT_EXP(LONG_MAX) * 2UL + 1)
 #endif
diff -Naur newlib-1.18.0.orig/newlib/libc/include/string.h newlib-1.18.0/newlib/libc/include/string.h
--- newlib-1.18.0.orig/newlib/libc/include/string.h	2008-06-18 17:27:27.000000000 +0200
+++ newlib-1.18.0/newlib/libc/include/string.h	2010-09-22 06:41:42.991911281 +0200
@@ -49,18 +49,11 @@
 #ifndef __STRICT_ANSI__
 char 	*_EXFUN(strtok_r,(char *, const char *, char **));
 
-int	 _EXFUN(bcmp,(const void *, const void *, size_t));
-void	 _EXFUN(bcopy,(const void *, void *, size_t));
-void	 _EXFUN(bzero,(void *, size_t));
-int	 _EXFUN(ffs,(int));
-char 	*_EXFUN(index,(const char *, int));
 _PTR	 _EXFUN(memccpy,(_PTR, const _PTR, int, size_t));
 _PTR	 _EXFUN(mempcpy,(_PTR, const _PTR, size_t));
 _PTR	 _EXFUN(memmem, (const _PTR, size_t, const _PTR, size_t));
-char 	*_EXFUN(rindex,(const char *, int));
 char 	*_EXFUN(stpcpy,(char *, const char *));
 char 	*_EXFUN(stpncpy,(char *, const char *, size_t));
-int	 _EXFUN(strcasecmp,(const char *, const char *));
 char	*_EXFUN(strcasestr,(const char *, const char *));
 char 	*_EXFUN(strdup,(const char *));
 char 	*_EXFUN(_strdup_r,(struct _reent *, const char *));
@@ -69,7 +62,6 @@
 char 	*_EXFUN(strerror_r,(int, char *, size_t));
 size_t	 _EXFUN(strlcat,(char *, const char *, size_t));
 size_t	 _EXFUN(strlcpy,(char *, const char *, size_t));
-int	 _EXFUN(strncasecmp,(const char *, const char *, size_t));
 size_t	 _EXFUN(strnlen,(const char *, size_t));
 char 	*_EXFUN(strsep,(char **, const char *));
 char	*_EXFUN(strlwr,(char *));
@@ -81,20 +73,6 @@
 int     _EXFUN(strtosigno, (const char *__name));
 #endif
 
-/* These function names are used on Windows and perhaps other systems.  */
-#ifndef strcmpi
-#define strcmpi strcasecmp
-#endif
-#ifndef stricmp
-#define stricmp strcasecmp
-#endif
-#ifndef strncmpi
-#define strncmpi strncasecmp
-#endif
-#ifndef strnicmp
-#define strnicmp strncasecmp
-#endif
-
 #endif /* ! __STRICT_ANSI__ */
 
 #include <sys/string.h>
diff -Naur newlib-1.18.0.orig/newlib/libc/include/strings.h newlib-1.18.0/newlib/libc/include/strings.h
--- newlib-1.18.0.orig/newlib/libc/include/strings.h	1970-01-01 01:00:00.000000000 +0100
+++ newlib-1.18.0/newlib/libc/include/strings.h	2010-09-22 06:41:42.991911281 +0200
@@ -0,0 +1,44 @@
+/*
+ * strings.h
+ *
+ * Definitions for string operations.
+ */
+
+#ifndef _STRINGS_H_
+#define _STRINGS_H_
+
+#include "_ansi.h"
+#include <sys/reent.h>
+
+#include <sys/types.h> /* for size_t */
+#include <locale.h> /* for locale_t */
+
+_BEGIN_STD_C
+
+#ifndef __STRICT_ANSI__
+/* 
+ * Marked LEGACY in Open Group Base Specifications Issue 6/IEEE Std 1003.1-2004
+ * Removed from Open Group Base Specifications Issue 7/IEEE Std 1003.1-2008
+ */
+int	 _EXFUN(bcmp,(const void *, const void *, size_t));
+void	 _EXFUN(bcopy,(const void *, void *, size_t));
+void	 _EXFUN(bzero,(void *, size_t));
+char 	*_EXFUN(index,(const char *, int));
+char 	*_EXFUN(rindex,(const char *, int));
+#endif /* ! __STRICT_ANSI__ */
+
+int	 _EXFUN(ffs,(int));
+int	 _EXFUN(strcasecmp,(const char *, const char *));
+#if 0
+/* Not implemented */
+int	 _EXFUN(strcasecmp_l,(const char *, const char *, locale_t));
+#endif
+int	 _EXFUN(strncasecmp,(const char *, const char *, size_t));
+#if 0
+/* Not implemented */
+int	 _EXFUN(strncasecmp_l,(const char *, const char *, size_t, locale_t));
+#endif
+
+_END_STD_C
+
+#endif /* _STRINGS_H_ */
diff -Naur newlib-1.18.0.orig/newlib/libc/include/sys/sched.h newlib-1.18.0/newlib/libc/include/sys/sched.h
--- newlib-1.18.0.orig/newlib/libc/include/sys/sched.h	2002-06-20 21:51:24.000000000 +0200
+++ newlib-1.18.0/newlib/libc/include/sys/sched.h	2010-09-22 06:41:42.991911281 +0200
@@ -1,7 +1,7 @@
 /*
  *  Written by Joel Sherrill <joel@OARcorp.com>.
  *
- *  COPYRIGHT (c) 1989-2000.
+ *  COPYRIGHT (c) 1989-2010.
  *  On-Line Applications Research Corporation (OAR).
  *
  *  Permission to use, copy, modify, and distribute this software for any
@@ -14,51 +14,53 @@
  *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
  *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
  *
- *  $Id$
+ *  $Id$
  */
 
 
-#ifndef __POSIX_SYS_SCHEDULING_h
-#define __POSIX_SYS_SCHEDULING_h
+#ifndef _SYS_SCHED_H_
+#define _SYS_SCHED_H_
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <sys/unistd.h>
-
-#include <sys/types.h>
-#include <sys/time.h>
-
-/* Scheduling Policies, P1003.1b-1993, p. 250
-   NOTE:  SCHED_SPORADIC added by P1003.4b/D8, p. 34.  */
-
+/* Scheduling Policies */
+/* Open Group Specifications Issue 6 */
+#if defined(__CYGWIN__)
+#define SCHED_OTHER    3
+#else
 #define SCHED_OTHER    0
+#endif
+
 #define SCHED_FIFO     1
 #define SCHED_RR       2
 
 #if defined(_POSIX_SPORADIC_SERVER)
-#define SCHED_SPORADIC 3 
+#define SCHED_SPORADIC 4
 #endif
 
-/* Scheduling Parameters, P1003.1b-1993, p. 249
-   NOTE:  Fields whose name begins with "ss_" added by P1003.4b/D8, p. 33.  */
+/* Scheduling Parameters */
+/* Open Group Specifications Issue 6 */
 
 struct sched_param {
   int sched_priority;           /* Process execution scheduling priority */
 
-#if defined(_POSIX_SPORADIC_SERVER)
-  int ss_low_priority;          /* Low scheduling priority for sporadic */
+#if defined(_POSIX_SPORADIC_SERVER) || defined(_POSIX_THREAD_SPORADIC_SERVER)
+  int sched_ss_low_priority;    /* Low scheduling priority for sporadic */
                                 /*   server */
-  struct timespec ss_replenish_period; 
+  struct timespec sched_ss_repl_period;
                                 /* Replenishment period for sporadic server */
-  struct timespec ss_initial_budget;   /* Initial budget for sporadic server */
+  struct timespec sched_ss_init_budget;
+                               /* Initial budget for sporadic server */
+  int sched_ss_max_repl;       /* Maximum pending replenishments for */
+                               /* sporadic server */
 #endif
 };
 
 #ifdef __cplusplus
 }
-#endif 
+#endif
 
 #endif
 /* end of include file */
diff -Naur newlib-1.18.0.orig/newlib/libc/include/sys/types.h newlib-1.18.0/newlib/libc/include/sys/types.h
--- newlib-1.18.0.orig/newlib/libc/include/sys/types.h	2009-09-28 18:42:21.000000000 +0200
+++ newlib-1.18.0/newlib/libc/include/sys/types.h	2010-10-04 09:23:34.965316864 +0200
@@ -176,7 +176,11 @@
 #endif
 typedef _ssize_t ssize_t;
 
-#ifndef __CYGWIN__
+#if defined(__rtems__)
+typedef _mode_t mode_t;
+#endif
+
+#if !defined(__CYGWIN__) && !defined(__rtems__)
 #ifdef __MS_types__
 typedef	char *	addr_t;
 typedef int mode_t;
@@ -349,6 +353,7 @@
   int inheritsched;
   int schedpolicy;
   struct sched_param schedparam;
+  size_t guardsize;
 #endif /* !defined(__XMK__) */
 
   /* P1003.4b/D8, p. 54 adds cputime_clock_allowed attribute.  */
diff -Naur newlib-1.18.0.orig/newlib/libc/include/sys/unistd.h newlib-1.18.0/newlib/libc/include/sys/unistd.h
--- newlib-1.18.0.orig/newlib/libc/include/sys/unistd.h	2009-12-17 20:43:43.000000000 +0100
+++ newlib-1.18.0/newlib/libc/include/sys/unistd.h	2010-09-22 06:41:42.992911566 +0200
@@ -93,7 +93,7 @@
 pid_t   _EXFUN(getpgrp, (void ));
 pid_t   _EXFUN(getpid, (void ));
 pid_t   _EXFUN(getppid, (void ));
-#ifdef __CYGWIN__
+#if defined(__CYGWIN__) || defined(__rtems__)
 pid_t   _EXFUN(getsid, (pid_t));
 #endif
 #if !defined(__INSIDE_CYGWIN__)
@@ -142,7 +142,7 @@
 #endif
 void *  _EXFUN(sbrk,  (ptrdiff_t __incr));
 #if !defined(__INSIDE_CYGWIN__)
-#if defined(__CYGWIN__)
+#if defined(__CYGWIN__) || defined(__rtems__)
 int     _EXFUN(setegid, (gid_t __gid ));
 int     _EXFUN(seteuid, (uid_t __uid ));
 #endif
diff -Naur newlib-1.18.0.orig/newlib/libc/machine/powerpc/Makefile.am newlib-1.18.0/newlib/libc/machine/powerpc/Makefile.am
--- newlib-1.18.0.orig/newlib/libc/machine/powerpc/Makefile.am	2007-05-24 19:33:35.000000000 +0200
+++ newlib-1.18.0/newlib/libc/machine/powerpc/Makefile.am	2010-09-22 06:41:42.992911566 +0200
@@ -10,7 +10,7 @@
 
 AM_CFLAGS = -I $(srcdir)/../../stdio -I $(srcdir)/../../stdlib
 
-lib_a_SOURCES = setjmp.S times.c
+lib_a_SOURCES = setjmp.S
 lib_a_CCASFLAGS=$(AM_CCASFLAGS)
 lib_a_CFLAGS=$(AM_CFLAGS)
 lib_a_LIBADD = @extra_objs@
diff -Naur newlib-1.18.0.orig/newlib/libc/machine/powerpc/Makefile.in newlib-1.18.0/newlib/libc/machine/powerpc/Makefile.in
--- newlib-1.18.0.orig/newlib/libc/machine/powerpc/Makefile.in	2009-10-21 00:44:03.000000000 +0200
+++ newlib-1.18.0/newlib/libc/machine/powerpc/Makefile.in	2010-09-22 06:41:42.992911566 +0200
@@ -51,7 +51,7 @@
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 lib_a_AR = $(AR) $(ARFLAGS)
-am_lib_a_OBJECTS = lib_a-setjmp.$(OBJEXT) lib_a-times.$(OBJEXT)
+am_lib_a_OBJECTS = lib_a-setjmp.$(OBJEXT)
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
@@ -173,7 +173,7 @@
 AM_CCASFLAGS = $(INCLUDES)
 noinst_LIBRARIES = lib.a
 AM_CFLAGS = -I $(srcdir)/../../stdio -I $(srcdir)/../../stdlib
-lib_a_SOURCES = setjmp.S times.c
+lib_a_SOURCES = setjmp.S
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 lib_a_LIBADD = @extra_objs@
@@ -184,7 +184,7 @@
 all: all-am
 
 .SUFFIXES:
-.SUFFIXES: .S .c .o .obj
+.SUFFIXES: .S .o .obj
 am--refresh:
 	@:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
@@ -245,18 +245,6 @@
 lib_a-setjmp.obj: setjmp.S
 	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-setjmp.obj `if test -f 'setjmp.S'; then $(CYGPATH_W) 'setjmp.S'; else $(CYGPATH_W) '$(srcdir)/setjmp.S'; fi`
 
-.c.o:
-	$(COMPILE) -c $<
-
-.c.obj:
-	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-lib_a-times.o: times.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.o `test -f 'times.c' || echo '$(srcdir)/'`times.c
-
-lib_a-times.obj: times.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.obj `if test -f 'times.c'; then $(CYGPATH_W) 'times.c'; else $(CYGPATH_W) '$(srcdir)/times.c'; fi`
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
diff -Naur newlib-1.18.0.orig/newlib/libc/machine/powerpc/times.c newlib-1.18.0/newlib/libc/machine/powerpc/times.c
--- newlib-1.18.0.orig/newlib/libc/machine/powerpc/times.c	2002-07-22 22:26:51.000000000 +0200
+++ newlib-1.18.0/newlib/libc/machine/powerpc/times.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,36 +0,0 @@
-/* Time support routines for PowerPC.
- *
- * Written by Aldy Hernandez.
- */
-
-#include <_ansi.h>
-#include <reent.h>
-#include <sys/time.h>
-#include <sys/times.h>
-#include <sys/resource.h>
-
-clock_t
-times (struct tms *tp)
-{
-  struct rusage usage;
-  union {
-    struct rusage r;
-    /* Newlib's rusage has only 2 fields.  We need to make room for
-       when we call the system's rusage.  This should be enough.  */
-    int filler[32];
-  } host_ru;
-
-  getrusage (RUSAGE_SELF, (void *)&host_ru);
-
-  if (tp)
-    {
-      tp->tms_utime = host_ru.r.ru_utime.tv_sec * 1000
-	+ host_ru.r.ru_utime.tv_usec;
-      tp->tms_stime = host_ru.r.ru_stime.tv_sec * 1000
-	+ host_ru.r.ru_stime.tv_usec;
-      tp->tms_cutime = 0;	/* user time, children */
-      tp->tms_cstime = 0;	/* system time, children */
-    }
-
-  return tp->tms_utime;
-}
diff -Naur newlib-1.18.0.orig/newlib/libc/misc/ffs.c newlib-1.18.0/newlib/libc/misc/ffs.c
--- newlib-1.18.0.orig/newlib/libc/misc/ffs.c	2003-06-06 21:57:51.000000000 +0200
+++ newlib-1.18.0/newlib/libc/misc/ffs.c	2010-09-22 06:41:42.995911299 +0200
@@ -24,7 +24,7 @@
 
 No supporting OS subroutines are required.  */
 
-#include <_ansi.h>
+#include <strings.h>
 
 int
 _DEFUN(ffs, (word),
diff -Naur newlib-1.18.0.orig/newlib/libc/posix/opendir.c newlib-1.18.0/newlib/libc/posix/opendir.c
--- newlib-1.18.0.orig/newlib/libc/posix/opendir.c	2003-06-06 21:57:51.000000000 +0200
+++ newlib-1.18.0/newlib/libc/posix/opendir.c	2010-09-22 06:41:42.996911555 +0200
@@ -74,6 +74,7 @@
 	dirp->dd_len = 512;
 
 	if (dirp->dd_buf == NULL) {
+		free(dirp);
 		close (fd);
 		return NULL;
 	}
diff -Naur newlib-1.18.0.orig/newlib/libc/posix/rewinddir.c newlib-1.18.0/newlib/libc/posix/rewinddir.c
--- newlib-1.18.0.orig/newlib/libc/posix/rewinddir.c	2003-06-06 21:57:51.000000000 +0200
+++ newlib-1.18.0/newlib/libc/posix/rewinddir.c	2010-09-22 06:41:42.996911555 +0200
@@ -48,7 +48,7 @@
 #ifdef HAVE_DD_LOCK
 	__lock_acquire_recursive(dirp->dd_lock);
 #endif
-	_seekdir((dirp), (off_t)0);
+	_seekdir((dirp), 0L);
 #ifdef HAVE_DD_LOCK
 	__lock_release_recursive(dirp->dd_lock);
 #endif
diff -Naur newlib-1.18.0.orig/newlib/libc/posix/telldir.c newlib-1.18.0/newlib/libc/posix/telldir.c
--- newlib-1.18.0.orig/newlib/libc/posix/telldir.c	2008-11-27 22:01:40.000000000 +0100
+++ newlib-1.18.0/newlib/libc/posix/telldir.c	2010-09-22 06:41:42.996911555 +0200
@@ -67,7 +67,7 @@
 #define	NDIRHASH	32	/* Num of hash lists, must be a power of 2 */
 #define	LOCHASH(i)	((i)&(NDIRHASH-1))
 
-static long	dd_loccnt;	/* Index of entry for sequential readdir's */
+static long	dd_loccnt = 1;	/* Index of entry for sequential readdir's */
 static struct	ddloc *dd_hash[NDIRHASH];   /* Hash list heads for ddlocs */
 __LOCK_INIT(static, dd_hash_lock);
 
@@ -119,40 +119,46 @@
 	register struct ddloc *lp;
 	register struct ddloc **prevlp;
 	struct dirent *dp;
-	extern long lseek();
 
 #ifdef HAVE_DD_LOCK
 	__lock_acquire(dd_hash_lock);
 #endif
-	prevlp = &dd_hash[LOCHASH(loc)];
-	lp = *prevlp;
-	while (lp != NULL) {
-		if (lp->loc_index == loc)
-			break;
-		prevlp = &lp->loc_next;
-		lp = lp->loc_next;
-	}
-	if (lp == NULL) {
+	if (loc != 0) {
+		prevlp = &dd_hash[LOCHASH(loc)];
+		lp = *prevlp;
+		while (lp != NULL) {
+			if (lp->loc_index == loc)
+				break;
+			prevlp = &lp->loc_next;
+			lp = lp->loc_next;
+		}
+		if (lp == NULL) {
 #ifdef HAVE_DD_LOCK
-		__lock_release(dd_hash_lock);
+			__lock_release(dd_hash_lock);
 #endif
-		return;
-	}
-	if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
-		goto found;
-	(void) lseek(dirp->dd_fd, lp->loc_seek, 0);
-	dirp->dd_seek = lp->loc_seek;
-	dirp->dd_loc = 0;
-	while (dirp->dd_loc < lp->loc_loc) {
-		dp = readdir(dirp);
-		if (dp == NULL)
-			break;
-	}
+			return;
+		}
+		if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
+			goto found;
+		(void) lseek(dirp->dd_fd, lp->loc_seek, 0);
+		dirp->dd_seek = lp->loc_seek;
+		dirp->dd_loc = 0;
+		while (dirp->dd_loc < lp->loc_loc) {
+			dp = readdir(dirp);
+			if (dp == NULL)
+				break;
+		}
 found:
 #ifdef SINGLEUSE
-	*prevlp = lp->loc_next;
-	free((caddr_t)lp);
+		*prevlp = lp->loc_next;
+		free((caddr_t)lp);
 #endif
+	} else {
+		// loc 0 means rewinding
+		(void) lseek(dirp->dd_fd, 0, 0);
+		dirp->dd_seek = 0;
+		dirp->dd_loc = 0;
+	}
 #ifdef HAVE_DD_LOCK
 	__lock_release(dd_hash_lock);
 #endif
@@ -169,26 +175,26 @@
 	__lock_acquire(dd_hash_lock);
 #endif
 	for (i = 0; i < NDIRHASH; ++i) {
+		struct ddloc head;
 		register struct ddloc *lp;
 		register struct ddloc *prevlp;
+
 		lp = dd_hash[i];
-		while (lp != NULL && lp->loc_dirp == dirp) {
-			dd_hash[i] = lp->loc_next;
-			prevlp = lp;
-			free((caddr_t)lp);
-			lp = prevlp->loc_next;
-		}
-		prevlp = lp;
+		head.loc_next = lp;
+		prevlp = &head;
 		while (lp != NULL) {
-			lp = lp->loc_next;
-			if (lp != NULL && lp->loc_dirp == dirp) {
-				prevlp->loc_next = lp->loc_next;
+			struct ddloc *nextlp;
+
+			nextlp = lp->loc_next;
+			if (lp->loc_dirp == dirp) {
+				prevlp->loc_next = nextlp;
 				free((caddr_t)lp);
-				lp = prevlp;
 			}
 			else
 				prevlp = lp;
+			lp = nextlp;
 		}
+		dd_hash[i] = head.loc_next;
 	}
 #ifdef HAVE_DD_LOCK
 	__lock_release(dd_hash_lock);
diff -Naur newlib-1.18.0.orig/newlib/libc/search/db_local.h newlib-1.18.0/newlib/libc/search/db_local.h
--- newlib-1.18.0.orig/newlib/libc/search/db_local.h	2002-06-25 01:05:08.000000000 +0200
+++ newlib-1.18.0/newlib/libc/search/db_local.h	2010-09-22 06:41:42.997911326 +0200
@@ -102,11 +102,11 @@
 typedef struct __db {
 	DBTYPE type;			/* Underlying db type. */
 	int (*close)(struct __db *);
-	int (*del)(const struct __db *, const DBT *, u_int);
-	int (*get)(const struct __db *, const DBT *, DBT *, u_int);
-	int (*put)(const struct __db *, DBT *, const DBT *, u_int);
-	int (*seq)(const struct __db *, DBT *, DBT *, u_int);
-	int (*sync)(const struct __db *, u_int);
+	int (*del)(const struct __db *, const DBT *, __uint32_t);
+	int (*get)(const struct __db *, const DBT *, DBT *, __uint32_t);
+	int (*put)(const struct __db *, DBT *, const DBT *, __uint32_t);
+	int (*seq)(const struct __db *, DBT *, DBT *, __uint32_t);
+	int (*sync)(const struct __db *, __uint32_t);
 	void *internal;			/* Access method private. */
 	int (*fd)(const struct __db *);
 } DB;
diff -Naur newlib-1.18.0.orig/newlib/libc/search/extern.h newlib-1.18.0/newlib/libc/search/extern.h
--- newlib-1.18.0.orig/newlib/libc/search/extern.h	2002-06-20 21:51:31.000000000 +0200
+++ newlib-1.18.0/newlib/libc/search/extern.h	2010-09-22 06:41:42.997911326 +0200
@@ -43,7 +43,7 @@
 int	 __big_split(HTAB *, BUFHEAD *, BUFHEAD *, BUFHEAD *,
 		int, __uint32_t, SPLIT_RETURN *);
 int	 __buf_free(HTAB *, int, int);
-void	 __buf_init(HTAB *, int);
+void	 __buf_init(HTAB *, __uint32_t);
 __uint32_t	 __call_hash(HTAB *, char *, int);
 int	 __delpair(HTAB *, BUFHEAD *, int);
 int	 __expand_table(HTAB *);
diff -Naur newlib-1.18.0.orig/newlib/libc/search/hash_buf.c newlib-1.18.0/newlib/libc/search/hash_buf.c
--- newlib-1.18.0.orig/newlib/libc/search/hash_buf.c	2004-05-26 19:57:10.000000000 +0200
+++ newlib-1.18.0/newlib/libc/search/hash_buf.c	2010-09-22 06:41:42.997911326 +0200
@@ -118,7 +118,7 @@
 	int newpage;	/* If prev_bp set, indicates a new overflow page. */
 {
 	BUFHEAD *bp;
-	__uint32_t is_disk_mask;
+	ptrdiff_t is_disk_mask;
 	int is_disk, segment_ndx;
 	SEGMENT segp;
 
@@ -298,7 +298,7 @@
 extern void
 __buf_init(hashp, nbytes)
 	HTAB *hashp;
-	int nbytes;
+	__uint32_t nbytes;
 {
 	BUFHEAD *bfp;
 	int npages;
diff -Naur newlib-1.18.0.orig/newlib/libc/search/hash.h newlib-1.18.0/newlib/libc/search/hash.h
--- newlib-1.18.0.orig/newlib/libc/search/hash.h	2008-07-02 20:38:45.000000000 +0200
+++ newlib-1.18.0/newlib/libc/search/hash.h	2010-09-22 06:41:42.997911326 +0200
@@ -82,7 +82,7 @@
 
 /* Hash Table Information */
 typedef struct hashhdr {		/* Disk resident portion */
-	int		magic;		/* Magic NO for hash tables */
+	__uint32_t	magic;		/* Magic NO for hash tables */
 	int		version;	/* Version ID */
 	__uint32_t	lorder;		/* Byte Order */
 	int		bsize;		/* Bucket/Page Size */
@@ -97,7 +97,7 @@
 	int		high_mask;	/* Mask to modulo into entire table */
 	int		low_mask;	/* Mask to modulo into lower half of 
 					 * table */
-	int		ffactor;	/* Fill factor */
+	__uint32_t	ffactor;	/* Fill factor */
 	int		nkeys;		/* Number of keys in hash table */
 	int		hdrpages;	/* Size of table header */
 	int		h_charkey;	/* value of hash(CHARKEY) */
diff -Naur newlib-1.18.0.orig/newlib/libc/stdlib/putenv_r.c newlib-1.18.0/newlib/libc/stdlib/putenv_r.c
--- newlib-1.18.0.orig/newlib/libc/stdlib/putenv_r.c	2004-11-24 23:34:14.000000000 +0100
+++ newlib-1.18.0/newlib/libc/stdlib/putenv_r.c	2010-09-22 06:41:42.998911276 +0200
@@ -24,6 +24,7 @@
 #include <reent.h>
 #include <stdlib.h>
 #include <string.h>
+#include <strings.h>
 
 #include "envlock.h"
 
diff -Naur newlib-1.18.0.orig/newlib/libc/string/bcmp.c newlib-1.18.0/newlib/libc/string/bcmp.c
--- newlib-1.18.0.orig/newlib/libc/string/bcmp.c	2005-10-28 23:21:07.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/bcmp.c	2010-09-22 06:41:42.998911276 +0200
@@ -6,11 +6,11 @@
 	bcmp
 
 ANSI_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	int bcmp(const void *<[s1]>, const void *<[s2]>, size_t <[n]>);
 
 TRAD_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	int bcmp(<[s1]>, <[s2]>, <[n]>)
 	const void *<[s1]>;
 	const void *<[s2]>;
@@ -35,7 +35,7 @@
 	bcmp ansi pure
 */
 
-#include <string.h>
+#include <strings.h>
 
 int
 _DEFUN (bcmp, (m1, m2, n),
diff -Naur newlib-1.18.0.orig/newlib/libc/string/bcopy.c newlib-1.18.0/newlib/libc/string/bcopy.c
--- newlib-1.18.0.orig/newlib/libc/string/bcopy.c	2002-05-23 20:46:04.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/bcopy.c	2010-09-22 06:41:42.999911328 +0200
@@ -3,7 +3,7 @@
 	<<bcopy>>---copy memory regions
 
 ANSI_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	void bcopy(const void *<[in]>, void *<[out]>, size_t <[n]>);
 
 TRAD_SYNOPSIS
@@ -26,7 +26,7 @@
 	bcopy - pure
 */
 
-#include <string.h>
+#include <strings.h>
 
 void
 _DEFUN (bcopy, (b1, b2, length),
diff -Naur newlib-1.18.0.orig/newlib/libc/string/bzero.c newlib-1.18.0/newlib/libc/string/bzero.c
--- newlib-1.18.0.orig/newlib/libc/string/bzero.c	2002-05-23 20:46:04.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/bzero.c	2010-09-22 06:41:42.999911328 +0200
@@ -6,11 +6,11 @@
 	bzero
 
 ANSI_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	void bzero(void *<[b]>, size_t <[length]>);
 
 TRAD_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	void bzero(<[b]>, <[length]>)
 	void *<[b]>;
 	size_t <[length]>;
@@ -30,7 +30,7 @@
 <<bzero>> requires no supporting OS subroutines.
 */
 
-#include <string.h>
+#include <strings.h>
 
 _VOID
 _DEFUN (bzero, (b, length),
diff -Naur newlib-1.18.0.orig/newlib/libc/string/index.c newlib-1.18.0/newlib/libc/string/index.c
--- newlib-1.18.0.orig/newlib/libc/string/index.c	2000-02-17 20:39:48.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/index.c	2010-09-22 06:41:42.999911328 +0200
@@ -10,7 +10,7 @@
 	char * index(const char *<[string]>, int <[c]>);
 
 TRAD_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	char * index(<[string]>, <[c]>);
 	char *<[string]>;
 	int *<[c]>;
@@ -33,7 +33,8 @@
 	index - pure
 */
 
-#include <string.h>
+#include <strings.h>
+#include <string.h> /* strchr */
 
 char *
 _DEFUN (index, (s, c),
diff -Naur newlib-1.18.0.orig/newlib/libc/string/memccpy.c newlib-1.18.0/newlib/libc/string/memccpy.c
--- newlib-1.18.0.orig/newlib/libc/string/memccpy.c	2002-07-23 23:38:00.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/memccpy.c	2010-09-22 06:42:08.242911422 +0200
@@ -92,12 +92,11 @@
   _CONST char *src = src0;
   long *aligned_dst;
   _CONST long *aligned_src;
-  int   len =  len0;
   char endchar = endchar0 & 0xff;
 
   /* If the size is small, or either SRC or DST is unaligned,
      then punt into the byte copy loop.  This should be rare.  */
-  if (!TOO_SMALL(len) && !UNALIGNED (src, dst))
+  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
     {
       int i;
       unsigned long mask = 0;
@@ -116,14 +115,14 @@
 
 
       /* Copy one long word at a time if possible.  */
-      while (len >= LITTLEBLOCKSIZE)
+      while (len0 >= LITTLEBLOCKSIZE)
         {
           unsigned long buffer = (unsigned long)(*aligned_src);
           buffer ^=  mask;
           if (DETECTNULL (buffer))
             break; /* endchar is found, go byte by byte from here */
           *aligned_dst++ = *aligned_src++;
-          len -= LITTLEBLOCKSIZE;
+          len0 -= LITTLEBLOCKSIZE;
         }
 
        /* Pick up any residual with a byte copier.  */
@@ -131,7 +130,7 @@
       src = (char*)aligned_src;
     }
 
-  while (len--)
+  while (len0--)
     {
       if ((*dst++ = *src++) == endchar)
         {
diff -Naur newlib-1.18.0.orig/newlib/libc/string/memcpy.c newlib-1.18.0/newlib/libc/string/memcpy.c
--- newlib-1.18.0.orig/newlib/libc/string/memcpy.c	2008-12-11 18:27:56.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/memcpy.c	2010-09-22 06:42:08.242911422 +0200
@@ -72,30 +72,29 @@
   _CONST char *src = src0;
   long *aligned_dst;
   _CONST long *aligned_src;
-  int   len =  len0;
 
   /* If the size is small, or either SRC or DST is unaligned,
      then punt into the byte copy loop.  This should be rare.  */
-  if (!TOO_SMALL(len) && !UNALIGNED (src, dst))
+  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
     {
       aligned_dst = (long*)dst;
       aligned_src = (long*)src;
 
       /* Copy 4X long words at a time if possible.  */
-      while (len >= BIGBLOCKSIZE)
+      while (len0 >= BIGBLOCKSIZE)
         {
           *aligned_dst++ = *aligned_src++;
           *aligned_dst++ = *aligned_src++;
           *aligned_dst++ = *aligned_src++;
           *aligned_dst++ = *aligned_src++;
-          len -= BIGBLOCKSIZE;
+          len0 -= BIGBLOCKSIZE;
         }
 
       /* Copy one long word at a time if possible.  */
-      while (len >= LITTLEBLOCKSIZE)
+      while (len0 >= LITTLEBLOCKSIZE)
         {
           *aligned_dst++ = *aligned_src++;
-          len -= LITTLEBLOCKSIZE;
+          len0 -= LITTLEBLOCKSIZE;
         }
 
        /* Pick up any residual with a byte copier.  */
@@ -103,7 +102,7 @@
       src = (char*)aligned_src;
     }
 
-  while (len--)
+  while (len0--)
     *dst++ = *src++;
 
   return dst0;
diff -Naur newlib-1.18.0.orig/newlib/libc/string/memmove.c newlib-1.18.0/newlib/libc/string/memmove.c
--- newlib-1.18.0.orig/newlib/libc/string/memmove.c	2000-02-17 20:39:48.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/memmove.c	2010-09-22 06:42:08.243911169 +0200
@@ -88,14 +88,13 @@
   _CONST char *src = src_void;
   long *aligned_dst;
   _CONST long *aligned_src;
-  int   len =  length;
 
-  if (src < dst && dst < src + len)
+  if (src < dst && dst < src + length)
     {
       /* Destructive overlap...have to copy backwards */
-      src += len;
-      dst += len;
-      while (len--)
+      src += length;
+      dst += length;
+      while (length--)
 	{
 	  *--dst = *--src;
 	}
@@ -105,26 +104,26 @@
       /* Use optimizing algorithm for a non-destructive copy to closely 
          match memcpy. If the size is small or either SRC or DST is unaligned,
          then punt into the byte copy loop.  This should be rare.  */
-      if (!TOO_SMALL(len) && !UNALIGNED (src, dst))
+      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
         {
           aligned_dst = (long*)dst;
           aligned_src = (long*)src;
 
           /* Copy 4X long words at a time if possible.  */
-          while (len >= BIGBLOCKSIZE)
+          while (length >= BIGBLOCKSIZE)
             {
               *aligned_dst++ = *aligned_src++;
               *aligned_dst++ = *aligned_src++;
               *aligned_dst++ = *aligned_src++;
               *aligned_dst++ = *aligned_src++;
-              len -= BIGBLOCKSIZE;
+              length -= BIGBLOCKSIZE;
             }
 
           /* Copy one long word at a time if possible.  */
-          while (len >= LITTLEBLOCKSIZE)
+          while (length >= LITTLEBLOCKSIZE)
             {
               *aligned_dst++ = *aligned_src++;
-              len -= LITTLEBLOCKSIZE;
+              length -= LITTLEBLOCKSIZE;
             }
 
           /* Pick up any residual with a byte copier.  */
@@ -132,7 +131,7 @@
           src = (char*)aligned_src;
         }
 
-      while (len--)
+      while (length--)
         {
           *dst++ = *src++;
         }
diff -Naur newlib-1.18.0.orig/newlib/libc/string/mempcpy.c newlib-1.18.0/newlib/libc/string/mempcpy.c
--- newlib-1.18.0.orig/newlib/libc/string/mempcpy.c	2002-07-23 23:38:00.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/mempcpy.c	2010-09-22 06:42:08.243911169 +0200
@@ -69,30 +69,29 @@
   _CONST char *src = src0;
   long *aligned_dst;
   _CONST long *aligned_src;
-  int   len =  len0;
 
   /* If the size is small, or either SRC or DST is unaligned,
      then punt into the byte copy loop.  This should be rare.  */
-  if (!TOO_SMALL(len) && !UNALIGNED (src, dst))
+  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
     {
       aligned_dst = (long*)dst;
       aligned_src = (long*)src;
 
       /* Copy 4X long words at a time if possible.  */
-      while (len >= BIGBLOCKSIZE)
+      while (len0 >= BIGBLOCKSIZE)
         {
           *aligned_dst++ = *aligned_src++;
           *aligned_dst++ = *aligned_src++;
           *aligned_dst++ = *aligned_src++;
           *aligned_dst++ = *aligned_src++;
-          len -= BIGBLOCKSIZE;
+          len0 -= BIGBLOCKSIZE;
         }
 
       /* Copy one long word at a time if possible.  */
-      while (len >= LITTLEBLOCKSIZE)
+      while (len0 >= LITTLEBLOCKSIZE)
         {
           *aligned_dst++ = *aligned_src++;
-          len -= LITTLEBLOCKSIZE;
+          len0 -= LITTLEBLOCKSIZE;
         }
 
        /* Pick up any residual with a byte copier.  */
@@ -100,7 +99,7 @@
       src = (char*)aligned_src;
     }
 
-  while (len--)
+  while (len0--)
     *dst++ = *src++;
 
   return dst;
diff -Naur newlib-1.18.0.orig/newlib/libc/string/rindex.c newlib-1.18.0/newlib/libc/string/rindex.c
--- newlib-1.18.0.orig/newlib/libc/string/rindex.c	2000-02-17 20:39:48.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/rindex.c	2010-09-22 06:41:42.999911328 +0200
@@ -10,7 +10,7 @@
 	char * rindex(const char *<[string]>, int <[c]>);
 
 TRAD_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	char * rindex(<[string]>, <[c]>);
 	char *<[string]>;
 	int *<[c]>;
@@ -33,7 +33,8 @@
 	rindex - pure
 */
 
-#include <string.h>
+#include <strings.h>
+#include <string.h> /* strchr */
 
 char *
 _DEFUN (rindex, (s, c),
diff -Naur newlib-1.18.0.orig/newlib/libc/string/strcasecmp.c newlib-1.18.0/newlib/libc/string/strcasecmp.c
--- newlib-1.18.0.orig/newlib/libc/string/strcasecmp.c	2009-04-23 20:11:22.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/strcasecmp.c	2010-09-22 06:41:42.999911328 +0200
@@ -38,7 +38,7 @@
 	strcasecmp
 */
 
-#include <string.h>
+#include <strings.h>
 #include <ctype.h>
 
 int
diff -Naur newlib-1.18.0.orig/newlib/libc/string/strcat.c newlib-1.18.0/newlib/libc/string/strcat.c
--- newlib-1.18.0.orig/newlib/libc/string/strcat.c	2000-02-17 20:39:48.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/strcat.c	2010-09-22 06:41:43.000911965 +0200
@@ -33,12 +33,13 @@
 	strcat ansi pure
 */
 
+#include <stdint.h>
 #include <string.h>
 #include <limits.h>
 
 /* Nonzero if X is aligned on a "long" boundary.  */
 #define ALIGNED(X) \
-  (((long)X & (sizeof (long) - 1)) == 0)
+  (((uintptr_t)X & (sizeof (long) - 1)) == 0)
 
 #if LONG_MAX == 2147483647L
 #define DETECTNULL(X) (((X) - 0x01010101) & ~(X) & 0x80808080)
diff -Naur newlib-1.18.0.orig/newlib/libc/string/strchr.c newlib-1.18.0/newlib/libc/string/strchr.c
--- newlib-1.18.0.orig/newlib/libc/string/strchr.c	2008-05-22 04:31:46.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/strchr.c	2010-09-22 06:41:43.000911965 +0200
@@ -33,11 +33,12 @@
 	strchr ansi pure
 */
 
+#include <stdint.h>
 #include <string.h>
 #include <limits.h>
 
 /* Nonzero if X is not aligned on a "long" boundary.  */
-#define UNALIGNED(X) ((long)X & (sizeof (long) - 1))
+#define UNALIGNED(X) ((uintptr_t)X & (sizeof (long) - 1))
 
 /* How many bytes are loaded each iteration of the word copy loop.  */
 #define LBLOCKSIZE (sizeof (long))
diff -Naur newlib-1.18.0.orig/newlib/libc/string/strcmp.c newlib-1.18.0/newlib/libc/string/strcmp.c
--- newlib-1.18.0.orig/newlib/libc/string/strcmp.c	2000-02-17 20:39:48.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/strcmp.c	2010-09-22 06:41:43.000911965 +0200
@@ -35,12 +35,13 @@
 	strcmp ansi pure
 */
 
+#include <stdint.h>
 #include <string.h>
 #include <limits.h>
 
 /* Nonzero if either X or Y is not aligned on a "long" boundary.  */
 #define UNALIGNED(X, Y) \
-  (((long)X & (sizeof (long) - 1)) | ((long)Y & (sizeof (long) - 1)))
+  (((uintptr_t)X & (sizeof (long) - 1)) | ((uintptr_t)Y & (sizeof (long) - 1)))
 
 /* DETECTNULL returns nonzero if (long)X contains a NULL byte. */
 #if LONG_MAX == 2147483647L
diff -Naur newlib-1.18.0.orig/newlib/libc/string/strncasecmp.c newlib-1.18.0/newlib/libc/string/strncasecmp.c
--- newlib-1.18.0.orig/newlib/libc/string/strncasecmp.c	2009-04-23 20:11:22.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/strncasecmp.c	2010-09-22 06:41:43.000911965 +0200
@@ -6,11 +6,11 @@
 	strncasecmp
 
 ANSI_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	int strncasecmp(const char *<[a]>, const char * <[b]>, size_t <[length]>);
 
 TRAD_SYNOPSIS
-	#include <string.h>
+	#include <strings.h>
 	int strncasecmp(<[a]>, <[b]>, <[length]>)
 	char *<[a]>;
 	char *<[b]>;
@@ -40,7 +40,7 @@
 	strncasecmp
 */
 
-#include <string.h>
+#include <strings.h>
 #include <ctype.h>
 
 int 
diff -Naur newlib-1.18.0.orig/newlib/libc/string/strncmp.c newlib-1.18.0/newlib/libc/string/strncmp.c
--- newlib-1.18.0.orig/newlib/libc/string/strncmp.c	2000-02-17 20:39:48.000000000 +0100
+++ newlib-1.18.0/newlib/libc/string/strncmp.c	2010-09-22 06:41:43.001911396 +0200
@@ -36,12 +36,13 @@
 	strncmp ansi pure
 */
 
+#include <stdint.h>
 #include <string.h>
 #include <limits.h>
 
 /* Nonzero if either X or Y is not aligned on a "long" boundary.  */
 #define UNALIGNED(X, Y) \
-  (((long)X & (sizeof (long) - 1)) | ((long)Y & (sizeof (long) - 1)))
+  (((uintptr_t)X & (sizeof (long) - 1)) | ((uintptr_t)Y & (sizeof (long) - 1)))
 
 /* DETECTNULL returns nonzero if (long)X contains a NULL byte. */
 #if LONG_MAX == 2147483647L
diff -Naur newlib-1.18.0.orig/newlib/libc/string/str-two-way.h newlib-1.18.0/newlib/libc/string/str-two-way.h
--- newlib-1.18.0.orig/newlib/libc/string/str-two-way.h	2008-10-02 22:12:34.000000000 +0200
+++ newlib-1.18.0/newlib/libc/string/str-two-way.h	2010-10-06 05:18:05.477316263 +0200
@@ -1,5 +1,5 @@
 /* Byte-wise substring search, using the Two-Way algorithm.
- * Copyright (C) 2008 Eric Blake
+ * Copyright (C) 2008, 2010 Eric Blake
  * Permission to use, copy, modify, and distribute this software
  * is freely granted, provided that this notice is preserved.
  */
@@ -335,8 +335,8 @@
 		     a byte out of place, there can be no match until
 		     after the mismatch.  */
 		  shift = needle_len - period;
-		  memory = 0;
 		}
+		memory = 0;
 	      j += shift;
 	      continue;
 	    }
diff -Naur newlib-1.18.0.orig/newlib/libc/sys/linux/sys/dirent.h newlib-1.18.0/newlib/libc/sys/linux/sys/dirent.h
--- newlib-1.18.0.orig/newlib/libc/sys/linux/sys/dirent.h	2008-11-19 21:55:52.000000000 +0100
+++ newlib-1.18.0/newlib/libc/sys/linux/sys/dirent.h	2010-09-22 06:41:43.001911396 +0200
@@ -40,7 +40,7 @@
 int closedir(DIR *);
 
 /* internal prototype */
-void _seekdir(DIR *dir,off_t offset);
+void _seekdir(DIR *dir, long offset);
 DIR *_opendir(const char *);
 
 #ifndef _POSIX_SOURCE
diff -Naur newlib-1.18.0.orig/newlib/libc/sys/rtems/machine/_types.h newlib-1.18.0/newlib/libc/sys/rtems/machine/_types.h
--- newlib-1.18.0.orig/newlib/libc/sys/rtems/machine/_types.h	2009-12-17 17:10:41.000000000 +0100
+++ newlib-1.18.0/newlib/libc/sys/rtems/machine/_types.h	2010-09-22 06:41:43.001911396 +0200
@@ -20,6 +20,9 @@
 typedef long signed int _ssize_t;
 #endif
 #define __ssize_t_defined 1
+#elif defined(__sparc__) && defined(__LP64__)
+typedef long signed int _ssize_t;
+#define __ssize_t_defined 1
 #elif defined(__AVR__) || defined(__lm32__) || defined(__m32c__) || defined(__mips__) || defined(__PPC__) || defined(__sparc__) || defined(__sh__)
 typedef signed int _ssize_t;
 #define __ssize_t_defined 1
@@ -31,4 +34,25 @@
 
 typedef __int32_t blksize_t;
 typedef __int32_t blkcnt_t;
+
+/* EXPERIMENTAL: Use 64bit types */
+#if defined(__arm__) || defined(__i386__) || defined(__m68k__) || defined(__mips__) || defined(__PPC__) || defined(__sparc__)
+/* Use 64bit types */
+typedef __int64_t _off_t;
+#define __off_t_defined 1
+
+typedef __int64_t _fpos_t;
+#define __fpos_t_defined 1
+#else
+/* Use 32bit types */
+typedef __int32_t _off_t;
+#define __off_t_defined 1
+
+typedef __int32_t _fpos_t;
+#define __fpos_t_defined 1
+#endif
+
+typedef __uint32_t _mode_t;
+#define __mode_t_defined 1
+
 #endif
diff -Naur newlib-1.18.0.orig/newlib/libc/sys/rtems/sys/dirent.h newlib-1.18.0/newlib/libc/sys/rtems/sys/dirent.h
--- newlib-1.18.0.orig/newlib/libc/sys/rtems/sys/dirent.h	2004-01-08 20:25:21.000000000 +0100
+++ newlib-1.18.0/newlib/libc/sys/rtems/sys/dirent.h	2010-09-22 06:41:43.001911396 +0200
@@ -31,6 +31,10 @@
 void seekdir(DIR *dir, long loc);
 long telldir(DIR *dir);
 
+#ifdef _COMPILING_NEWLIB
+void _seekdir(DIR *dir, long offset);
+#endif
+
 #include <sys/types.h>
 
 #include <limits.h>
diff -Naur newlib-1.18.0.orig/newlib/libm/common/modfl.c newlib-1.18.0/newlib/libm/common/modfl.c
--- newlib-1.18.0.orig/newlib/libm/common/modfl.c	2009-04-18 00:15:43.000000000 +0200
+++ newlib-1.18.0/newlib/libm/common/modfl.c	2010-09-22 06:41:43.002911214 +0200
@@ -36,7 +36,7 @@
 long double
 modfl (long double x, long double *iptr)
 {
-  return modf(x, iptr);
+  return modf(x, (double*) iptr);
 }
 #endif
 
diff -Naur newlib-1.18.0.orig/newlib/libm/common/sf_llrint.c newlib-1.18.0/newlib/libm/common/sf_llrint.c
--- newlib-1.18.0.orig/newlib/libm/common/sf_llrint.c	2009-04-03 19:39:24.000000000 +0200
+++ newlib-1.18.0/newlib/libm/common/sf_llrint.c	2010-09-22 06:41:43.002911214 +0200
@@ -71,7 +71,7 @@
           GET_FLOAT_WORD (i0, t);
           /* Detect the all-zeros representation of plus and
              minus zero, which fails the calculation below. */
-          if ((i0 & ~(1 << 31)) == 0)
+          if ((i0 & ~((__uint32_t)1 << 31)) == 0)
               return 0;
           j0 = ((i0 >> 23) & 0xff) - 0x7f;
           i0 &= 0x7fffff;
diff -Naur newlib-1.18.0.orig/newlib/libm/common/sf_round.c newlib-1.18.0/newlib/libm/common/sf_round.c
--- newlib-1.18.0.orig/newlib/libm/common/sf_round.c	2005-02-24 20:02:35.000000000 +0100
+++ newlib-1.18.0/newlib/libm/common/sf_round.c	2010-09-22 06:41:43.002911214 +0200
@@ -38,7 +38,7 @@
           w &= 0x80000000;
           if (exponent_less_127 == -1)
             /* Result is +1.0 or -1.0. */
-            w |= (127 << 23);
+            w |= ((__uint32_t)127 << 23);
         }
       else
         {
diff -Naur newlib-1.18.0.orig/newlib/Makefile.am newlib-1.18.0/newlib/Makefile.am
--- newlib-1.18.0.orig/newlib/Makefile.am	2009-08-18 23:48:05.000000000 +0200
+++ newlib-1.18.0/newlib/Makefile.am	2010-09-22 06:41:43.002911214 +0200
@@ -81,7 +81,7 @@
 	libc.a
 endif
 
-noinst_DATA = stmp-targ-include
+BUILT_SOURCES = stmp-targ-include
 
 toollib_DATA = $(CRT0) $(CRT1)
 
diff -Naur newlib-1.18.0.orig/newlib/Makefile.in newlib-1.18.0/newlib/Makefile.in
--- newlib-1.18.0.orig/newlib/Makefile.in	2009-10-21 00:43:45.000000000 +0200
+++ newlib-1.18.0/newlib/Makefile.in	2010-09-22 06:41:43.003911219 +0200
@@ -122,7 +122,7 @@
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
-DATA = $(noinst_DATA) $(toollib_DATA)
+DATA = $(toollib_DATA)
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
 AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \
@@ -351,7 +351,7 @@
 @USE_LIBTOOL_FALSE@toollib_LIBRARIES = libm.a \
 @USE_LIBTOOL_FALSE@	libc.a
 
-noinst_DATA = stmp-targ-include
+BUILT_SOURCES = stmp-targ-include
 toollib_DATA = $(CRT0) $(CRT1)
 
 # The functions ldexp, frexp and modf are traditionally supplied in
@@ -411,7 +411,7 @@
 
 # dejagnu support
 RUNTESTFLAGS = 
-all: newlib.h
+all: $(BUILT_SOURCES) newlib.h
 	$(MAKE) $(AM_MAKEFLAGS) all-recursive
 
 .SUFFIXES:
@@ -725,14 +725,16 @@
 	done
 check-am:
 	$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU
-check: check-recursive
+check: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) check-recursive
 all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) $(DATA) newlib.h
 installdirs: installdirs-recursive
 installdirs-am:
 	for dir in "$(DESTDIR)$(toollibdir)" "$(DESTDIR)$(toollibdir)" "$(DESTDIR)$(toollibdir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
-install: install-recursive
+install: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
 uninstall: uninstall-recursive
@@ -758,6 +760,7 @@
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(BUILT_SOURCES)" || rm -f $(BUILT_SOURCES)
 clean: clean-recursive
 
 clean-am: clean-generic clean-libtool clean-toollibLIBRARIES \
@@ -833,8 +836,9 @@
 uninstall-am: uninstall-toollibDATA uninstall-toollibLIBRARIES \
 	uninstall-toollibLTLIBRARIES
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check-am \
-	ctags-recursive install-am install-strip tags-recursive
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all check \
+	check-am ctags-recursive install install-am install-strip \
+	tags-recursive
 
 .PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
 	all all-am am--refresh check check-DEJAGNU check-am clean \
