@c  COPYRIGHT (c) 1988-2013.
@c  On-Line Applications Research Corporation (OAR).
@c  All rights reserved.

@c TODO:
@c   + Ensure all macros are documented.
@c   + Verify which structures may actually be defined by a user
@c   + Add Go configuration.

@c Questions:
@c   + Should there be examples of defining your own
@c     Device Driver Table, Init task table, etc.?
@c

@chapter Configuring a System

@c
@c === Introduction ===
@c
@section Introduction

RTEMS must be configured for an application.  This configuration
encompasses a variety of information including the length of each clock
tick, the maximum number of each information RTEMS object that can
be created, the application initialization tasks, the task scheduling
algorithm to be used, and the device drivers in the application.

Although this information is contained in data structures that are used
by RTEMS at system initialization time, the data structures themselves
should only rarely to be generated by hand. RTEMS provides a set of
macros system which provides a simple standard mechanism to automate
the generation of these structures.

@ifset is-Ada
System configuration is ALWAYS done from C.  When developing
an Ada application, the user is responsible for creating at
least one C file which contains the Ada run-time initialization
and the RTEMS System Configuration.  There is no Ada binding
for RTEMS System Configuration information.  Thus all examples
and data structures shown in this chapter are in C.
@end ifset

@cindex confdefs.h
@findex confdefs.h
@cindex <rtems/confdefs.h>
@findex <rtems/confdefs.h>

The RTEMS header file @code{<rtems/confdefs.h>} is at the core of the
automatic generation of system configuration. It is based on the idea
of setting macros which define configuration parameters of interest to
the application and defaulting or calculating all others. This variety
of macros can automatically produce all of the configuration data
required for an RTEMS application.

Trivia: @code{confdefs} is shorthand for a @b{Configuration Defaults}.

As a general rule, application developers only specify values
for the configuration parameters of interest to them. They define what
resources or features they require. In most cases, when a parameter is
not specified, it defaults to zero (0) instances, a standards compliant
value, or disabled as appropriate. For example, by default there will be
256 task priority levels but this can be lowered by the application. This
number of priority levels is required to be compliant with the RTEID/ORKID
standards upon which the Classic API is based. There are similar cases
where the default is selected to be compliant with with the POSIX standard.

For each configuration parameter in the configuration tables, the macro
corresponding to that field is discussed. The RTEMS Maintainers
expect that all systems can be easily configured using the
@code{<rtems/confdefs.h>} mechanism and that using this mechanism will
avoid internal RTEMS configuration changes impacting applications.

@c
@c === Philosophy ===
@c
@section Default Value Selection Philosophy

The user should be aware that the defaults are intentionally set as
low as possible.  By default, no application resources are configured.
The @code{<rtems/confdefs.h>} file ensures that at least one application
task or thread is configured and that at least one of the initialization
task/thread tables is configured.

@c
@c === Sizing the RTEMS Workspace ===
@c
@section Sizing the RTEMS Workspace

The RTEMS Workspace is a user-specified block of memory reserved for
use by RTEMS.  The application should NOT modify this memory.  This area
consists primarily of the RTEMS data structures whose exact size depends
upon the values specified in the Configuration Table.  In addition,
task stacks and floating point context areas are dynamically allocated
from the RTEMS Workspace.

The @code{<rtems/confdefs.h>} mechanism calculates the size of the RTEMS
Workspace automatically.  It assumes that all tasks are floating point and
that all will be allocated the minimum stack space.  This calculation
includes the amount of memory that will be allocated for internal use
by RTEMS. The automatic calculation may underestimate the workspace
size truly needed by the application, in which case one can use the
@code{CONFIGURE_MEMORY_OVERHEAD} macro to add a value to the estimate. See
@ref{Configuring a System Specify Memory Overhead} for more details.

The memory area for the RTEMS Workspace is determined by the BSP.  In case the
RTEMS Workspace is too large for the available memory, then a fatal run-time
error occurs and the system terminates.

The file @code{<rtems/confdefs.h>} will calculate the value of the
@code{work_space_size} parameter of the Configuration Table. There
are many parameters the application developer can specify to
help @code{<rtems/confdefs.h>} in its calculations.  Correctly
specifying the application requirements via parameters such as
@code{CONFIGURE_EXTRA_TASK_STACKS} and @code{CONFIGURE_MAXIMUM_TASKS}
is critical for production software.

For each class of objects, the allocation can operate in one of two ways.
The default way has an ceiling on the maximum number of object instances
which can concurrently exist in the system. Memory for all instances of
that object class is reserved at system initialization.  The second
way allocates memory for an initial number of objects and increases the
current allocation by a fixed increment when required. Both ways allocate
space from inside the RTEMS Workspace.

See @ref{Configuring a System Unlimited Objects} for more details about
the second way, which allows for dynamic allocation of objects and
therefore does not provide determinism.  This mode is useful mostly for
when the number of objects cannot be determined ahead of time or when
porting software for which you do not know the object requirements.

The space needed for stacks and for RTEMS objects will vary from
one version of RTEMS and from one target processor to another.
Therefore it is safest to use @code{<rtems/confdefs.h>} and specify
your application's requirements in terms of the numbers of objects and
multiples of @code{RTEMS_MINIMUM_STACK_SIZE}, as far as is possible. The
automatic estimates of space required will in general change when:

@itemize @bullet
@item a configuration parameter is changed,
@item task or interrupt stack sizes change,
@item the floating point attribute of a task changes,
@item task floating point attribute is altered,
@item RTEMS is upgraded, or
@item the target processor is changed.
@end itemize

Failure to provide enough space in the RTEMS Workspace may result in fatal
run-time errors terminating the system.

@c
@c === Potential Issues ===
@c
@section Potential Issues with RTEMS Workspace Size Estimation

The @code{<rtems/confdefs.h>} file estimates the amount of memory
required for the RTEMS Workspace.  This estimate is only as accurate
as the information given to @code{<rtems/confdefs.h>} and may be either
too high or too low for a variety of reasons.  Some of the reasons that
@code{<rtems/confdefs.h>} may reserve too much memory for RTEMS are:

@itemize @bullet
@item All tasks/threads are assumed to be floating point.
@end itemize

Conversely, there are many more reasons that the resource estimate could be
too low:

@itemize @bullet
@item Task/thread stacks greater than minimum size must be
accounted for explicitly by developer.

@item Memory for messages is not included.

@item Device driver requirements are not included.

@item Network stack requirements are not included.

@item Requirements for add-on libraries are not included.
@end itemize

In general, @code{<rtems/confdefs.h>} is very accurate when given enough
information.  However, it is quite easy to use a library and forget to
account for its resources.

@c
@c === Configuration Example ===
@c
@section Configuration Example

In the following example, the configuration information for a system
with a single message queue, four (4) tasks, and a timeslice of
fifty (50) milliseconds is as follows:

@example
@group
#include <bsp.h>

#define CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER
#define CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER

#define CONFIGURE_MICROSECONDS_PER_TICK   1000 /* 1 millisecond */
#define CONFIGURE_TICKS_PER_TIMESLICE       50 /* 50 milliseconds */

#define CONFIGURE_RTEMS_INIT_TASKS_TABLE

#define CONFIGURE_MAXIMUM_TASKS 4
#define CONFIGURE_MAXIMUM_MESSAGE_QUEUES 1

#define CONFIGURE_MESSAGE_BUFFER_MEMORY \
  CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE(20, sizeof(struct USER_MESSAGE))

#define CONFIGURE_INIT
#include <rtems/confdefs.h>
@end group
@end example

In this example, only a few configuration parameters are specified. The
impact of these are as follows:

@itemize @bullet

@item The example specified @code{CONFIGURE_RTEMS_INIT_TASK_TABLE}
but did not specify any additional parameters. This results in a
configuration of an application which will begin execution of a single
initialization task named @code{Init} which is non-preemptible and at
priority one (1).

@item By specifying @code{CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER},
this application is configured to have a clock tick device
driver. Without a clock tick device driver, RTEMS has no way to know
that time is passing and will be unable to support delays and wall
time. Further configuration details about time are
provided. Per @code{CONFIGURE_MICROSECONDS_PER_TICK} and
@code{CONFIGURE_TICKS_PER_TIMESLICE}, the user specified they wanted a
clock tick to occur each millisecond, and that the length of a timeslice
would be fifty (50) milliseconds.

@item By specifying @code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER},
the application will include a console device driver. Although the
console device driver may support a combination of multiple serial
ports and display and keyboard combinations, it is only required to
provide a single device named @code{/dev/console}. This device will
be used for Standard Input, Output and Error I/O Streams. Thus when
@code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER} is specified, implicitly
three (3) file descriptors are reserved for the Standard I/O Streams and
those file descriptors are associated with @code{/dev/console} during
initialization. All console devices are expected to support the POSIX
@i{termios} interface.

@item The example above specifies via @code{CONFIGURE_MAXIMUM_TASKS}
that the application requires a maximum of four (4)
simultaneously existing Classic API tasks. Similarly, by specifying
@code{CONFIGURE_MAXIMUM_MESSAGE_QUEUES}, there may be a maximum of only
one (1) concurrently existent Classic API message queues.

@item The most surprising configuration parameter in this example is the
use of @code{CONFIGURE_MESSAGE_BUFFER_MEMORY}. Message buffer memory is
allocated from the RTEMS Workspace and must be accounted for. In this
example, the single message queue will have up to twenty (20) messages
of type @code{struct USER_MESSAGE}.

@item The @code{CONFIGURE_INIT} constant must be defined in order to
make @code{<rtems/confdefs.h>} instantiate the configuration data
structures.  This can only be defined in one source file per
application that includes @code{<rtems/confdefs.h>} or the symbol
table will be instantiated multiple times and linking errors
produced.

@end itemize

This example illustrates that parameters have default values. Among
other things, the application implicitly used the following defaults:

@itemize @bullet
@item All unspecified types of communications and synchronization objects
in the Classic and POSIX Threads API have maximums of zero (0).

@item The filesystem will be the default filesystem which is the In-Memory File
System (IMFS).

@item The application will have the default number of priority levels.

@item The minimum task stack size will be that recommended by RTEMS for
the target architecture.
@end itemize

@c
@c === Unlimited Objects ===
@c
@subsection Unlimited Objects

In real-time embedded systems the RAM is normally a limited, critical
resource and dynamic allocation is avoided as much as possible to
ensure predictable, deterministic execution times. For such cases, see
@ref{Configuring a System Sizing the RTEMS Workspace} for an overview
of how to tune the size of the workspace.  Frequently when users are
porting software to RTEMS the precise resource requirements of the
software is unknown. In these situations users do not need to control
the size of the workspace very tightly because they just want to get
the new software to run; later they can tune the workspace size as needed.

The following object classes in the Classic API can be configured in
unlimited mode:

@itemize @bullet
@item Tasks
@item Timers
@item Semaphores
@item Message Queues
@item Periods
@item Barriers
@item Partitions
@item Regions
@item Ports
@end itemize

Additionally, the following object classes from the POSIX API can be
configured in unlimited mode:

@itemize @bullet
@item Threads
@item Mutexes
@item Condition Variables
@item Keys
@item Timers
@item Message Queues
@item Message Queue Descriptors
@item Semaphores
@item Barriers
@item Read/Write Locks
@item Spinlocks
@end itemize

Due to how the POSIX object memory requirements are configured the
unlimited object support does not provide unlimited size declarations
for POSIX keys or queued signals.

Users are cautioned that using unlimited objects is not recommended for
production software unless the dynamic growth is absolutely required. It
is generally considered a safer embedded systems programming practice to
know the system limits rather than experience an out of memory error
at an arbitrary and largely unpredictable time in the field.

@c
@c === Per Object Class Unlimited Object Instances ===
@c
@subsection Per Object Class Unlimited Object Instances

@findex rtems_resource_unlimited
When the number of objects is not known ahead of time, RTEMS provides an
auto-extending mode that can be enabled individually for each object
type by using the macro @code{rtems_resource_unlimited}. This takes a value
as a parameter, and is used to set the object maximum number field in
an API Configuration table. The value is an allocation unit size. When
RTEMS is required to grow the object table it is grown by this
size. The kernel will return the object memory back to the RTEMS Workspace
when an object is destroyed. The kernel will only return an allocated
block of objects to the RTEMS Workspace if at least half the allocation
size of free objects remain allocated. RTEMS always keeps one
allocation block of objects allocated. Here is an example of using
@code{rtems_resource_unlimited}:

@example
#define CONFIGURE_MAXIMUM_TASKS rtems_resource_unlimited(5)
@end example

@findex rtems_resource_is_unlimited
@findex rtems_resource_maximum_per_allocation
Object maximum specifications can be evaluated with the
@code{rtems_resource_is_unlimited} and
@code{rtems_resource_maximum_per_allocation} macros.

@c
@c === Unlimited Object Instances ===
@c
@subsection Unlimited Object Instances

To ease the burden of developers who are porting new software RTEMS
also provides the capability to make all object classes listed above
operate in unlimited mode in a simple manner. The application developer
is only responsible for enabling unlimited objects and specifying the
allocation size.

@c
@c === CONFIGURE_OBJECTS_UNLIMITED ===
@c
@subsection Enable Unlimited Object Instances

@findex CONFIGURE_OBJECTS_UNLIMITED

@table @b
@item CONSTANT:
@code{CONFIGURE_OBJECTS_UNLIMITED}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_OBJECTS_UNLIMITED} enables @code{rtems_resource_unlimited}
mode for Classic API and POSIX API objects that do not already have a
specific maximum limit defined.

@subheading NOTES:
When using unlimited objects, it is common practice to also specify
@code{CONFIGURE_UNIFIED_WORK_AREAS} so the system operates with a single
pool of memory for both RTEMS and application memory allocations.

@c
@c === CONFIGURE_OBJECTS_ALLOCATION_SIZE ===
@c
@subsection Specify Unlimited Objects Allocation Size

@table @b
@item CONSTANT:
@code{CONFIGURE_OBJECTS_ALLOCATION_SIZE}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
If not defined and @code{CONFIGURE_OBJECTS_UNLIMITED} is defined, the
default value is eight (8).

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_OBJECTS_ALLOCATION_SIZE} provides an
allocation size to use for @code{rtems_resource_unlimited} when using
@code{CONFIGURE_OBJECTS_UNLIMITED}.

@subheading NOTES:
By allowing users to declare all resources as being unlimited
the user can avoid identifying and limiting the resources used.
@code{CONFIGURE_OBJECTS_UNLIMITED} does not support varying the allocation
sizes for different objects; users who want that much control can define
the @code{rtems_resource_unlimited} macros themselves.

@example
#define CONFIGURE_OBJECTS_UNLIMITED
#define CONFIGURE_OBJECTS_ALLOCATION_SIZE 5
@end example

@c
@c === Classic API Configuration ===
@c
@section Classic API Configuration

This section defines the Classic API related system configuration
parameters supported by @code{<rtems/confdefs.h>}.

@c
@c === CONFIGURE_MAXIMUM_TASKS ===
@c
@subsection Specify Maximum Classic API Tasks

@findex CONFIGURE_MAXIMUM_TASKS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_TASKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_TASKS} is the maximum number of Classic API
Tasks that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

The calculations for the required memory in the RTEMS Workspace
for tasks assume that each task has a minimum stack size and
has floating point support enabled.  The configuration parameter
@code{CONFIGURE_EXTRA_TASK_STACKS} is used to specify task stack
requirements @b{ABOVE} the minimum size required.  See
@ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum}
for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}.

The maximumm number of POSIX threads is specified by
@code{CONFIGURE_MAXIMUM_POSIX_THREADS}.
@c XXX - Add xref to CONFIGURE_MAXIMUM_POSIX_THREADS.

A future enhancement to @code{<rtems/confdefs.h>} could be to eliminate
the assumption that all tasks have floating point enabled. This would
require the addition of a new configuration parameter to specify the
number of tasks which enable floating point support.

@c
@c === CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS ===
@c
@subsection Disable Classic API Notepads

@findex CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS

@table @b
@item CONSTANT:
@code{CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, and Classic API Notepads are supported.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_DISABLE_CLASSIC_API_NOTEPADS} should be defined if the
user does not want to have support for Classic API Notepads in their
application.

@subheading NOTES:
Disabling Classic API Notepads saves the allocation of sixteen (16)
thirty-two bit integers. This saves sixty-four bytes per task/thread
plus the allocation overhead. Notepads are rarely used in applications
and this can save significant memory in a low RAM system.

@c
@c === CONFIGURE_MAXIMUM_TIMERS ===
@c
@subsection Specify Maximum Classic API Timers

@findex CONFIGURE_MAXIMUM_TIMERS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_TIMERS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_TIMERS} is the maximum number of Classic API
Timers that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_SEMAPHORES ===
@c
@subsection Specify Maximum Classic API Semaphores

@findex CONFIGURE_MAXIMUM_SEMAPHORES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_SEMAPHORES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_SEMAPHORES} is the maximum number of Classic
API Semaphores that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_MESSAGE_QUEUES ===
@c
@subsection Specify Maximum Classic API Message Queues

@findex CONFIGURE_MAXIMUM_MESSAGE_QUEUES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_MESSAGE_QUEUES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_MESSAGE_QUEUES} is the maximum number of Classic
API Message Queues that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_BARRIERS ===
@c
@subsection Specify Maximum Classic API Barriers

@findex CONFIGURE_MAXIMUM_BARRIERS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_BARRIERS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_BARRIERS} is the maximum number of Classic
API Barriers that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_PERIODS ===
@c
@subsection Specify Maximum Classic API Periods

@findex CONFIGURE_MAXIMUM_PERIODS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_PERIODS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_PERIODS} is the maximum number of Classic
API Periods that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_PARTITIONS ===
@c
@subsection Specify Maximum Classic API Partitions

@findex CONFIGURE_MAXIMUM_PARTITIONS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_PARTITIONS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_PARTITIONS} is the maximum number of Classic
API Partitions that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_REGIONS ===
@c
@subsection Specify Maximum Classic API Regions

@findex CONFIGURE_MAXIMUM_REGIONS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_REGIONS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_REGIONS} is the maximum number of Classic
API Regions that can be concurrently active.

@subheading NOTES:
None.

@c
@c === CONFIGURE_MAXIMUM_PORTS ===
@c
@subsection Specify Maximum Classic API Ports

@findex CONFIGURE_MAXIMUM_PORTS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_PORTS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_PORTS} is the maximum number of Classic
API Ports that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_USER_EXTENSIONS ===
@c
@subsection Specify Maximum Classic API User Extensions

@findex CONFIGURE_MAXIMUM_USER_EXTENSIONS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_USER_EXTENSIONS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_USER_EXTENSIONS} is the maximum number of Classic
API User Extensions that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === Classic API Initialization Task Configuration ===
@c
@section Classic API Initialization Tasks Table Configuration

The @code{<rtems/confdefs.h>} configuration system can automatically
generate an Initialization Tasks Table named
@code{Initialization_tasks} with a single entry.  The following
parameters control the generation of that table.

@c
@c === CONFIGURE_RTEMS_INIT_TASKS_TABLE ===
@c
@subsection Instantiate Classic API Initialization Task Table

@findex CONFIGURE_RTEMS_INIT_TASKS_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_RTEMS_INIT_TASKS_TABLE}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_RTEMS_INIT_TASKS_TABLE} is defined if the user wishes
to use a Classic RTEMS API Initialization Task Table. The table built by
@code{<rtems/confdefs.h>} specifies the parameters for a single task. This
is sufficient for applications which initialization the system from a
single task.

By default, this field is not defined as the user MUST select their own
API for initialization tasks.

@subheading NOTES:
The application may choose to use the initialization tasks or threads
table from another API.

A compile time error will be generated if the user does not configure
any initialization tasks or threads.

@c
@c === CONFIGURE_INIT_TASK_ENTRY_POINT ===
@c
@subsection Specifying Classic API Initialization Task Entry Point

@findex CONFIGURE_INIT_TASK_ENTRY_POINT

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_ENTRY_POINT}

@item DATA TYPE:
Task entry function pointer (@code{rtems_task_entry}).

@item RANGE:
Valid task entry function pointer.

@item DEFAULT VALUE:
The default value is @code{Init}.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_ENTRY_POINT} is the entry point (a.k.a. function
name) of the single initialization task defined by the Classic API
Initialization Tasks Table.

@subheading NOTES:
The user must implement the function @code{Init} or the function name provided
in this configuration parameter.

@c
@c === CONFIGURE_INIT_TASK_NAME ===
@c
@subsection Specifying Classic API Initialization Task Name

@findex CONFIGURE_INIT_TASK_NAME

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_NAME}

@item DATA TYPE:
RTEMS Name (@code{rtems_name}).

@item RANGE:
Any value.

@item DEFAULT VALUE:
The default value is @code{rtems_build_name( 'U', 'I', '1', ' ' )}.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_NAME} is the name of the single initialization
task defined by the Classic API Initialization Tasks Table.

@subheading NOTES:
None.

@c
@c === CONFIGURE_INIT_TASK_STACK_SIZE ===
@c
@subsection Specifying Classic API Initialization Task Stack Size

@findex CONFIGURE_INIT_TASK_STACK_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is RTEMS_MINIMUM_STACK_SIZE.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_STACK_SIZE} is the stack size of the single
initialization task defined by the Classic API Initialization Tasks Table.

@subheading NOTES:
If the stack size specified is greater than the configured minimum,
it must be accounted for in @code{CONFIGURE_EXTRA_TASK_STACKS}.
See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum}
for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}.

@c
@c === CONFIGURE_INIT_TASK_PRIORITY ===
@c
@subsection Specifying Classic API Initialization Task Priority

@findex CONFIGURE_INIT_TASK_PRIORITY

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_PRIORITY}

@item DATA TYPE:
RTEMS Task Priority (@code{rtems_task_priority}).

@item RANGE:
One (1) to CONFIGURE_MAXIMUM_PRIORITY.

@item DEFAULT VALUE:
The default value is 1, which is the highest priority in the
Classic API.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_PRIORITY} is the initial priority of the single
initialization task defined by the Classic API Initialization Tasks Table.

@subheading NOTES:
None.

@c
@c === CONFIGURE_INIT_TASK_ATTRIBUTES ===
@c
@subsection Specifying Classic API Initialization Task Attributes

@findex CONFIGURE_INIT_TASK_ATTRIBUTES

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_ATTRIBUTES}


@item DATA TYPE:
RTEMS Attributes (@code{rtems_attribute}).

@item RANGE:
Valid task attribute sets.

@item DEFAULT VALUE:
The default value is @code{RTEMS_DEFAULT_ATTRIBUTES}.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_ATTRIBUTES} is the task attributes of the single
initialization task defined by the Classic API Initialization Tasks Table.

@subheading NOTES:
None.

@c
@c === CONFIGURE_INIT_TASK_INITIAL_MODES ===
@c
@subsection Specifying Classic API Initialization Task Modes

@findex CONFIGURE_INIT_TASK_INITIAL_MODES

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_INITIAL_MODES}

@item DATA TYPE:
RTEMS Mode (@code{rtems_mode}).

@item RANGE:
Valid task mode sets.

@item DEFAULT VALUE:
The default value is @code{RTEMS_NO_PREEMPT}.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_INITIAL_MODES} is the initial execution mode of
the single initialization task defined by the Classic API Initialization
Tasks Table.

@subheading NOTES:
None.

@c
@c === CONFIGURE_INIT_TASK_ARGUMENTS ===
@c
@subsection Specifying Classic API Initialization Task Arguments

@findex CONFIGURE_INIT_TASK_ARGUMENTS

@table @b
@item CONSTANT:
@code{CONFIGURE_INIT_TASK_ARGUMENTS}

@item DATA TYPE:
RTEMS Task Argument (@code{rtems_task_argument}).

@item RANGE:
Complete range of the type.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INIT_TASK_ARGUMENTS} is the task argument of the single
initialization task defined by the Classic API Initialization Tasks Table.

@subheading NOTES:
None.

@c
@c === CONFIGURE_HAS_OWN_INIT_TASK_TABLE ===
@c
@subsection Not Using Generated Initialization Tasks Table

@findex CONFIGURE_HAS_OWN_INIT_TASK_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_HAS_OWN_INIT_TASK_TABLE}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_HAS_OWN_INIT_TASK_TABLE} is defined if the user wishes
to define their own Classic API Initialization Tasks Table.  This table
should be named @code{Initialization_tasks}.

@subheading NOTES:
This is a seldom used configuration parameter. The most likely use case
is when an application desires to have more than one initialization task.

@c
@c === POSIX API Configuration ===
@c
@section POSIX API Configuration

The parameters in this section are used to configure resources
for the RTEMS POSIX API.  They are only relevant if the POSIX API
is enabled at configure time using the @code{--enable-posix} option.

@c
@c === CONFIGURE_MAXIMUM_POSIX_THREADS ===
@c
@subsection Specify Maximum POSIX API Threads

@findex CONFIGURE_MAXIMUM_POSIX_THREADS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_THREADS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_THREADS} is the maximum number of POSIX API
Threads that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

This calculations for the required memory in the RTEMS Workspace
for threads assume that each thread has a minimum stack size and
has floating point support enabled.  The configuration parameter
@code{CONFIGURE_EXTRA_TASK_STACKS} is used to specify thread stack
requirements @b{ABOVE} the minimum size required.
See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum}
for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}.

The maximum number of Classic API Tasks is specified by
@code{CONFIGURE_MAXIMUM_TASKS}.

All POSIX threads have floating point enabled.

@c XXX - Add xref to CONFIGURE_MAXIMUM_TASKS.

@c
@c === CONFIGURE_MAXIMUM_POSIX_MUTEXES ===
@c
@subsection Specify Maximum POSIX API Mutexes

@findex CONFIGURE_MAXIMUM_POSIX_MUTEXES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_MUTEXES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_MUTEXES} is the maximum number of POSIX
API Mutexes that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES ===
@c
@subsection Specify Maximum POSIX API Condition Variables

@findex CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_CONDITION_VARIABLES} is the maximum number
of POSIX API Condition Variables that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_POSIX_KEYS ===
@c
@subsection Specify Maximum POSIX API Keys

@findex CONFIGURE_MAXIMUM_POSIX_KEYS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_KEYS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_KEYS} is the maximum number of POSIX
API Keys that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c XXX - Key pairs

@c
@c === CONFIGURE_MAXIMUM_POSIX_TIMERS ===
@c
@subsection Specify Maximum POSIX API Timers

@findex CONFIGURE_MAXIMUM_POSIX_TIMERS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_TIMERS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_TIMERS} is the maximum number of POSIX
API Timers that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS ===
@c
@subsection Specify Maximum POSIX API Queued Signals

@findex CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_QUEUED_SIGNALS} is the maximum number of POSIX
API Queued Signals that can be concurrently active.

@subheading NOTES:
None.

@c
@c === CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES ===
@c
@subsection Specify Maximum POSIX API Message Queues

@findex CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES} is the maximum number of POSIX
API Message Queues that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c XXX - memory for buffers note

@c
@c === CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS ===
@c
@subsection Specify Maximum POSIX API Message Queue Descriptors

@findex CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
greater than or equal to @code{CONFIGURE_MAXIMUM_POSIX_MESSAGES_QUEUES}

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS} is the maximum
number of POSIX API Message Queue Descriptors that can be concurrently
active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUE_DESCRIPTORS} should be
greater than or equal to @code{CONFIGURE_MAXIMUM_POSIX_MESSAGE_QUEUES}.

@c
@c === CONFIGURE_MAXIMUM_POSIX_SEMAPHORES ===
@c
@subsection Specify Maximum POSIX API Semaphores

@findex CONFIGURE_MAXIMUM_POSIX_SEMAPHORES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_SEMAPHORES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_SEMAPHORES} is the maximum number of POSIX
API Semaphores that can be concurrently active.

@subheading NOTES:
None.

@c
@c === CONFIGURE_MAXIMUM_POSIX_BARRIERS ===
@c
@subsection Specify Maximum POSIX API Barriers

@findex CONFIGURE_MAXIMUM_POSIX_BARRIERS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_BARRIERS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_BARRIERS} is the maximum number of POSIX
API Barriers that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_POSIX_SPINLOCKS ===
@c
@subsection Specify Maximum POSIX API Spinlocks

@findex CONFIGURE_MAXIMUM_POSIX_SPINLOCKS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_SPINLOCKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_SPINLOCKS} is the maximum number of POSIX
API Spinlocks that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === CONFIGURE_MAXIMUM_POSIX_RWLOCKS ===
@c
@subsection Specify Maximum POSIX API Read/Write Locks

@findex CONFIGURE_MAXIMUM_POSIX_RWLOCKS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_POSIX_RWLOCKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_POSIX_RWLOCKS} is the maximum number of POSIX
API Read/Write Locks that can be concurrently active.

@subheading NOTES:
This object class can be configured in unlimited allocation mode.

@c
@c === POSIX Initialization Threads Table Configuration ===
@c
@section POSIX Initialization Threads Table Configuration

The @code{<rtems/confdefs.h>} configuration system can automatically
generate a POSIX Initialization Threads Table named
@code{POSIX_Initialization_threads} with a single entry.  The following
parameters control the generation of that table.

@c
@c === CONFIGURE_POSIX_INIT_THREAD_TABLE ===
@c
@subsection Instantiate POSIX API Initialization Thread Table

@findex CONFIGURE_POSIX_INIT_THREAD_TABLE

@table @b
@item CONSTANT:
@findex CONFIGURE_POSIX_INIT_THREAD_TABLE

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This field is not defined by default, as the user MUST select their own
API for initialization tasks.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_POSIX_INIT_THREAD_TABLE} is defined if the user wishes
to use a POSIX API Initialization Threads Table.  The table built
by @code{<rtems/confdefs.h>} specifies the parameters for a single
thread. This is sufficient for applications which initialization the
system from a
single task.

By default, this field is not defined as the user MUST select their own
API for initialization tasks.

@subheading NOTES:
The application may choose to use the initialization tasks or threads
table from another API.

A compile time error will be generated if the user does not configure
any initialization tasks or threads.

@c
@c === CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT ===
@c
@subsection Specifying POSIX API Initialization Thread Entry Point

@findex CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT

@table @b
@item CONSTANT:
@code{CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT}

@item DATA TYPE:
POSIX thread function pointer (@code{void *(*entry_point)(void *)}).

@item RANGE:
Undefined or a valid POSIX thread function pointer.

@item DEFAULT VALUE:
The default value is @code{POSIX_Init}.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_POSIX_INIT_THREAD_ENTRY_POINT} is the entry point
(a.k.a. function name) of the single initialization thread defined by
the POSIX API Initialization Threads Table.

@subheading NOTES:
The user must implement the function @code{POSIX_Init} or the function name
provided in this configuration parameter.

@c
@c === CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE ===
@c
@subsection Specifying POSIX API Initialization Thread Stack Size

@findex CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 2 * RTEMS_MINIMUM_STACK_SIZE.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_POSIX_INIT_THREAD_STACK_SIZE} is the stack size of the
single initialization thread defined by the POSIX API Initialization
Threads Table.

@subheading NOTES:
If the stack size specified is greater than the configured minimum,
it must be accounted for in @code{CONFIGURE_EXTRA_TASK_STACKS}.
See @ref{Configuring a System Reserve Task/Thread Stack Memory Above Minimum}
for more information about @code{CONFIGURE_EXTRA_TASK_STACKS}.

@c
@c === CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE ===
@c
@subsection Not Using Generated POSIX Initialization Threads Table

@findex CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_POSIX_HAS_OWN_INIT_THREAD_TABLE} is defined if the
user wishes to define their own POSIX API Initialization Threads Table.
This table should be named @code{POSIX_Initialization_threads}.

@subheading NOTES:
This is a seldom used configuration parameter. The most likely use case
is when an application desires to have more than one initialization task.

@c
@c === Basic System Information ===
@c
@section Basic System Information

This section defines the general system configuration parameters supported by
@code{<rtems/confdefs.h>}.

@c
@c === CONFIGURE_UNIFIED_WORK_AREAS ===
@c
@subsection Separate or Unified Work Areas

@findex CONFIGURE_UNIFIED_WORK_AREAS
@cindex unified work areas
@cindex separate work areas
@cindex RTEMS Workspace
@cindex C Program Heap

@table @b
@item CONSTANT:
@code{CONFIGURE_UNIFIED_WORK_AREAS}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, which specifies that the C Program Heap
and the RTEMS Workspace will be separate.

@end table

@subheading DESCRIPTION:
When defined, the C Program Heap and the RTEMS Workspace will be one pool
of memory.

When not defined, there will be separate memory pools for the RTEMS
Workspace and C Program Heap.

@subheading NOTES:
Having separate pools does have some advantages in the event a task blows
a stack or writes outside its memory area. However, in low memory systems
the overhead of the two pools plus the potential for unused memory in
either pool is very undesirable.

In high memory environments, this is desirable when you want to use the
RTEMS "unlimited" objects option.  You will be able to create objects
until you run out of all available memory rather then just until you
run out of RTEMS Workspace.

@c
@c === CONFIGURE_MICROSECONDS_PER_TICK ===
@c
@subsection Length of Each Clock Tick

@findex CONFIGURE_MICROSECONDS_PER_TICK
@cindex tick quantum

@table @b
@item CONSTANT:
@code{CONFIGURE_MICROSECONDS_PER_TICK}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
This is not defined by default. When not defined,
the clock tick quantum is configured to be 10,000
microseconds which is ten (10) milliseconds.

@end table

@subheading DESCRIPTION:
This constant is  used to specify the length of time between clock ticks.

When the clock tick quantum value is too low, the system will spend so
much time processing clock ticks that it does not have processing time
available to perform application work. In this case, the system will
become unresponsive.

The lowest practical time quantum varies widely based upon the speed
of the target hardware and the architectural overhead associated with
interrupts. In general terms, you do not want to configure it lower than
is needed for the application.

The clock tick quantum should be selected such that it all blocking and
delay times in the application are evenly divisible by it. Otherwise,
rounding errors will be introduced which may negatively impact the
application.

@subheading NOTES:
This configuration parameter has no impact if the Clock Tick Device
driver is not configured.

There may be BSP specific limits on the resolution or maximum value of
a clock tick quantum.

@c
@c === CONFIGURE_TICKS_PER_TIMESLICE ===
@c
@subsection Specifying Timeslicing Quantum

@findex CONFIGURE_TICKS_PER_TIMESLICE
@cindex ticks per timeslice

@table @b
@item CONSTANT:
@code{CONFIGURE_TICKS_PER_TIMESLICE}


@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 50.

@end table

@subheading DESCRIPTION:
This configuration parameter specifies the length of the timeslice
quantum in ticks for each task.

@subheading NOTES:
This configuration parameter has no impact if the Clock Tick Device
driver is not configured.

@c
@c === CONFIGURE_MAXIMUM_PRIORITY ===
@c
@subsection Specifying the Number of Thread Priority Levels

@findex CONFIGURE_MAXIMUM_PRIORITY
@cindex maximum priority
@cindex number of priority levels

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_PRIORITY}

@item DATA TYPE:
Unsigned integer (@code{uint8_t}).

@item RANGE:
Valid values for this configuration parameter must be one (1) less than
than a power of two (2) between 4 and 256 inclusively.  In other words,
valid values are 3, 7, 31, 63, 127, and 255.

@item DEFAULT VALUE:
The default value is 255, because RTEMS must support 256 priority levels to be
compliant with various standards. These priorities range from zero (0) to 255.

@end table

@subheading DESCRIPTION:
This configuration parameter specified the maximum numeric priority
of any task in the system and one less that the number of priority levels
in the system.

Reducing the number of priorities in the system reduces the amount of
memory allocated from the RTEMS Workspace.

@subheading NOTES:
The numerically greatest priority is the logically lowest priority in
the system and will thus be used by the IDLE task.

Priority zero (0) is reserved for internal use by RTEMS and is not
available to applications.

With some schedulers, reducing the number of priorities can reduce the
amount of memory used by the scheduler. For example, the Deterministic
Priority Scheduler (DPS) used by default uses three pointers of storage
per priority level. Reducing the number of priorities from 256 levels
to sixteen (16) can reduce memory usage by about three (3) kilobytes.

@c
@c === CONFIGURE_MINIMUM_TASK_STACK_SIZE ===
@c
@subsection Specifying the Minimum Task Size

@findex CONFIGURE_MINIMUM_TASK_STACK_SIZE
@cindex minimum task stack size

@table @b
@item CONSTANT:
@code{CONFIGURE_MINIMUM_TASK_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
This is not defined by default, which sets the executive to the recommended
minimum stack size for this processor.

@end table

@subheading DESCRIPTION:
The configuration parameter is set to the number of bytes the application
wants the minimum stack size to be for every task or thread in the system.

Adjusting this parameter should be done with caution. Examining the actual
usage using the Stack Checker Usage Reporting facility is recommended.

@subheading NOTES:
This parameter can be used to lower the minimum from that
recommended. This can be used in low memory systems to reduce memory
consumption for stacks. However, this must be done with caution as it
could increase the possibility of a blown task stack.

This parameter can be used to increase the minimum from that
recommended. This can be used in higher memory systems to reduce the
risk of stack overflow without performing analysis on actual consumption.

@c
@c === CONFIGURE_INTERRUPT_STACK_SIZE ===
@c
@subsection Configuring the Size of the Interrupt Stack

@findex CONFIGURE_INTERRUPT_STACK_SIZE
@cindex interrupt stack size

@table @b
@item CONSTANT:
@code{CONFIGURE_INTERRUPT_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is CONFIGURE_MINIMUM_TASK_STACK_SIZE, which is the minimum
interrupt stack size.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_INTERRUPT_STACK_SIZE} is set to the size of the
interrupt stack.  The interrupt stack size is often set by the BSP but
since this memory may be allocated from the RTEMS Workspace, it must be
accounted for.

@subheading NOTES:
In some BSPs, changing this constant does NOT change the
size of the interrupt stack, only the amount of memory
reserved for it.

Patches which result in this constant only being used in memory
calculations when the interrupt stack is intended to be allocated
from the RTEMS Workspace would be welcomed by the RTEMS Project.

@c
@c === CONFIGURE_EXTRA_TASK_STACKS ===
@c
@subsection Reserve Task/Thread Stack Memory Above Minimum

@findex CONFIGURE_EXTRA_TASK_STACKS
@cindex memory for task tasks

@table @b
@item CONSTANT:
@code{CONFIGURE_EXTRA_TASK_STACKS}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
This configuration parameter is set to the number of bytes the
applications wishes to add to the task stack requirements calculated
by @code{<rtems/confdefs.h>}.

@subheading NOTES:
This parameter is very important.  If the application creates tasks with
stacks larger then the minimum, then that memory is NOT accounted for
by @code{<rtems/confdefs.h>}.

@c
@c === CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY ===
@c
@subsection Automatically Zeroing the RTEMS Workspace and C Program Heap

@findex CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY
@cindex clear C Program Heap
@cindex clear RTEMS Workspace
@cindex zero C Program Heap
@cindex zero RTEMS Workspace

@table @b
@item CONSTANT:
@code{CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, unless overridden by the BSP.
The default is @b{NOT} to zero out the RTEMS Workspace or C Program Heap.

@end table

@subheading DESCRIPTION:
This macro indicates whether RTEMS should zero the RTEMS Workspace and
C Program Heap as part of its initialization.  If defined, the memory
regions are zeroed.  Otherwise, they are not.

@subheading NOTES:
Zeroing memory can add significantly to system boot time. It is not
necessary for RTEMS but is often assumed by support libraries.

@c
@c === CONFIGURE_STACK_CHECKER_ENABLED ===
@c
@subsection Enable The Task Stack Usage Checker

@findex CONFIGURE_STACK_CHECKER_ENABLED

@table @b
@item CONSTANT:
@code{CONFIGURED_STACK_CHECKER_ENABLED}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, and thus stack checking is disabled.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined when the application wishes to
enable run-time stack bounds checking.


@subheading NOTES:
In 4.9 and older, this configuration parameter was named
@code{STACK_CHECKER_ON}.

This increases the time required to create tasks as well as adding
overhead to each context switch.

@c
@c === CONFIGURE_INITIAL_EXTENSIONS ===
@c
@subsection Specify Application Specific User Extensions

@findex CONFIGURE_INITIAL_EXTENSIONS

@table @b
@item CONSTANT:
@code{CONFIGURE_INITIAL_EXTENSIONS}

@item DATA TYPE:
List of user extension initializers (@code{rtems_extensions_table}).

@item RANGE:
Undefined or a list of one or more user extensions.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
If @code{CONFIGURE_INITIAL_EXTENSIONS} is defined by the application,
then this application specific set of initial extensions will be placed
in the initial extension table.

@subheading NOTES:
None.

@c
@c === Custom Stack Allocator ===
@c
@section Configuring Custom Task Stack Allocation

RTEMS allows the application or BSP to define its own allocation and
deallocation methods for task stacks. This can be used to place task
stacks in special areas of memory or to utilize a Memory Management Unit
so that stack overflows are detected in hardware.

@c
@c === CONFIGURE_TASK_STACK_ALLOCATOR_INIT ===
@c
@subsection Custom Task Stack Allocator Initialization

@findex CONFIGURE_TASK_STACK_ALLOCATOR_INIT

@table @b
@item CONSTANT:
@code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT}

@item DATA TYPE:
Function pointer.

@item RANGE:
Undefined, NULL or valid function pointer.

@item DEFAULT VALUE:
The default value is NULL, which indicates that
task stacks will be allocated from the RTEMS Workspace.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT} configures the initialization
method for an application or BSP specific task stack allocation
implementation.

@subheading NOTES:
A correctly configured system must configure the following to be consistent:

@itemize @bullet
@item @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT}
@item @code{CONFIGURE_TASK_STACK_ALLOCATOR}
@item @code{CONFIGURE_TASK_STACK_DEALLOCATOR}
@end itemize

@c
@c === CONFIGURE_TASK_STACK_ALLOCATOR ===
@c
@subsection Custom Task Stack Allocator

@findex CONFIGURE_TASK_STACK_ALLOCATOR

@cindex task stack allocator

@table @b
@item CONSTANT:
@code{CONFIGURE_TASK_STACK_ALLOCATOR}

@item DATA TYPE:
Function pointer.

@item RANGE:
Undefined or valid function pointer.

@item DEFAULT VALUE:
The default value is @code{_Workspace_Allocate}, which indicates
that task stacks will be allocated from the RTEMS Workspace.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_TASK_STACK_ALLOCATOR} may point to a user provided
routine to allocate task stacks.

@subheading NOTES:
A correctly configured system must configure the following to be consistent:

@itemize @bullet
@item @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT}
@item @code{CONFIGURE_TASK_STACK_ALLOCATOR}
@item @code{CONFIGURE_TASK_STACK_DEALLOCATOR}
@end itemize

@c
@c === CONFIGURE_TASK_STACK_DEALLOCATOR ===
@c
@subsection Custom Task Stack Deallocator

@findex CONFIGURE_TASK_STACK_DEALLOCATOR
@cindex task stack deallocator

@table @b
@item CONSTANT:
@code{CONFIGURE_TASK_STACK_DEALLOCATOR}

@item DATA TYPE:
Function pointer.

@item RANGE:
Undefined or valid function pointer.

@item DEFAULT VALUE:
The default value is @code{_Workspace_Free}, which indicates that
task stacks will be allocated from the RTEMS Workspace.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_TASK_STACK_DEALLOCATOR} may point to a user provided
routine to free task stacks.

@subheading NOTES:
A correctly configured system must configure the following to be consistent:

@itemize @bullet
@item @code{CONFIGURE_TASK_STACK_ALLOCATOR_INIT}
@item @code{CONFIGURE_TASK_STACK_ALLOCATOR}
@item @code{CONFIGURE_TASK_STACK_DEALLOCATOR}
@end itemize

@c
@c === Classic API Message Buffers ===
@c
@section Configuring Memory for Classic API Message Buffers

This section describes the configuration parameters related to specifying
the amount of memory reserved for Classic API Message Buffers.

@c
@c === CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE ===
@c
@subsection Calculate Memory for a Single Classic Message API Message Queue

@findex CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE
@cindex memory for a single message queue's buffers

@table @b
@item CONSTANT:
@code{CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE(max_messages, size_per)}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is None.

@end table

@subheading DESCRIPTION:
This is a helper macro which is used to assist in computing the total
amount of memory required for message buffers.  Each message queue will
have its own configuration with maximum message size and maximum number
of pending messages.

The interface for this macro is as follows:

@example
CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE(max_messages, size_per)
@end example

Where @code{max_messages} is the maximum number of pending messages
and @code{size_per} is the size in bytes of the user message.

@subheading NOTES:
This macro is only used in support of @code{CONFIGURE_MESSAGE_BUFFER_MEMORY}.

@c
@c === CONFIGURE_MESSAGE_BUFFER_MEMORY ===
@c
@subsection Reserve Memory for All Classic Message API Message Queues

@findex CONFIGURE_MESSAGE_BUFFER_MEMORY
@cindex configure message queue buffer memory

@table @b
@item CONSTANT:
@code{CONFIGURE_MESSAGE_BUFFER_MEMORY}

@item DATA TYPE:
integer summation macro

@item RANGE:
undefined (zero) or calculation resulting in a positive integer

@item DEFAULT VALUE:
This is not defined by default, and zero (0) memory is reserved.

@end table

@subheading DESCRIPTION:
This macro is set to the number of bytes the application requires to be
reserved for pending Classic API Message Queue buffers.

@subheading NOTES:
The following illustrates how the help macro
@code{CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE} can be used to assist in
calculating the message buffer memory required.  In this example, there
are two message queues used in this application.  The first message
queue has maximum of 24 pending messages with the message structure
defined by the type @code{one_message_type}.  The other message queue
has maximum of 500 pending messages with the message structure defined
by the type @code{other_message_type}.

@example
@group
#define CONFIGURE_MESSAGE_BUFFER_MEMORY \
 (CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \
    24, sizeof(one_message_type) + \
  CONFIGURE_MESSAGE_BUFFERS_FOR_QUEUE( \
    500, sizeof(other_message_type) \
 )
@end group
@end example

@c
@c === Seldom Used Configuration Parameters ===
@c
@section Seldom Used Configuration Parameters

This section describes configuration parameters supported by
@code{<rtems/confdefs.h>} which are seldom used by applications. These
parameters tend to be oriented to debugging system configurations
and providing work-arounds when the memory estimated by
@code{<rtems/confdefs.h>} is incorrect.

@c
@c === CONFIGURE_MEMORY_OVERHEAD ===
@c
@subsection Specify Memory Overhead

@findex CONFIGURE_MEMORY_OVERHEAD

@table @b
@item CONSTANT:
@code{CONFIGURE_MEMORY_OVERHEAD}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
Thie parameter is set to the number of kilobytes the application wishes
to add to the requirements calculated by @code{<rtems/confdefs.h>}.

@subheading NOTES:
This configuration parameter should only be used when it is suspected that
a bug in @code{<rtems/confdefs.h>} has resulted in an underestimation.
Typically the memory allocation will be too low when an application does
not account for all message queue buffers or task stacks.

@c
@c === CONFIGURE_HAS_OWN_CONFIGURATION_TABLE ===
@c
@subsection Do Not Generate Configuration Information

@findex CONFIGURE_HAS_OWN_CONFIGURATION_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_HAS_OWN_CONFIGURATION_TABLE}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
This configuration parameter should only be defined if the application
is providing their own complete set of configuration tables.

@subheading NOTES:
None.

@c
@c === C Library Support Configuration ===
@c
@section C Library Support Configuration

This section defines the file system and IO library
related configuration parameters supported by
@code{<rtems/confdefs.h>}.

@c
@c === CONFIGURE_MALLOC_STATISTICS ===
@c
@subsection Enable Malloc Family Statistics

@findex CONFIGURE_MALLOC_STATISTICS


@table @b
@item CONSTANT:
@code{CONFIGURE_MALLOC_STATISTICS}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, and Malloc Statistics are disabled.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined when the application wishes to
enable the gathering of more detailed statistics on the C Malloc Family
of routines.

@subheading NOTES:
None.

@c
@c === CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS ===
@c
@subsection Specify Maximum Number of File Descriptors

@findex CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS
@cindex maximum file descriptors

@table @b
@item CONSTANT:
@code{CONFIGURE_LIBIO_MAXIMUM_FILE_DESCRIPTORS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:

If @code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER} is defined, then the
default value is 3, otherwise the default value is 0.

Three file descriptors allows RTEMS to support standard input, output, and
error I/O streams on @code{/dev/console}.

@end table

@subheading DESCRIPTION:
This configuration parameter is set to the maximum number of file like objects
that can be concurrently open.

@subheading NOTES:
None.

@c
@c === CONFIGURE_TERMIOS_DISABLED ===
@c
@subsection Disable POSIX Termios Support

@findex CONFIGURE_TERMIOS_DISABLED

@table @b
@item CONSTANT:
@code{CONFIGURE_TERMIOS_DISABLED}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, and resources are reserved for the
termios functionality.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined if the software implementing
POSIX termios functionality is not going to be used by this application.

@subheading NOTES:
The termios support library should not be included in an application
executable unless it is directly referenced by the application or a
device driver.

@c
@c === CONFIGURE_NUMBER_OF_TERMIOS_PORTS ===
@c
@subsection Specify Maximum Termios Ports

@findex CONFIGURE_NUMBER_OF_TERMIOS_PORTS

@table @b
@item CONSTANT:
@code{CONFIGURE_NUMBER_OF_TERMIOS_PORTS}

@item DATA TYPE:
Unsigned integer.

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 1, so a console port can be used.

@end table

@subheading DESCRIPTION:
This configuration parameter is set to the number of ports using the
termios functionality.  Each concurrently active termios port requires
resources.

@subheading NOTES:
If the application will be using serial ports
including, but not limited to, the Console Device
(e.g. @code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER}), then it is
highly likely that this configuration parameter should NOT be is defined.

@c
@c === File System Configuration Parameters ===
@c
@section File System Configuration Parameters

This section defines File System related configuration parameters.

@c
@c === CONFIGURE_HAS_OWN_MOUNT_TABLE ===
@c
@subsection Providing Application Specific Mount Table

@findex CONFIGURE_HAS_OWN_MOUNT_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_HAS_OWN_MOUNT_TABLE}

@item DATA TYPE:
Undefined or an array of type @code{rtems_filesystem_mount_table_t}.

@item RANGE:
Undefined or an array of type @code{rtems_filesystem_mount_table_t}.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined when the application
provides their own filesystem mount table.  The mount table is an
array of @code{rtems_filesystem_mount_table_t} entries pointed
to by the global variable @code{rtems_filesystem_mount_table}.
The number of entries in this table is in an integer variable named
@code{rtems_filesystem_mount_table_t}.

@c XXX - is the variable name for the count right?

@subheading NOTES:
None.
@c XXX - Please provide an example

@c
@c === CONFIGURE_USE_MINIIMFS_AS_BASE_SYSTEM ===
@c
@subsection Configure miniIMFS as Root File System

@findex CONFIGURE_USE_MINIIMFS_AS_BASE_FILESYSTEM

@table @b
@item CONSTANT:
@code{CONFIGURE_USE_MINIIMFS_AS_BASE_FILESYSTEM}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default. If no other root file system
configuration parameters are specified, the IMFS will be used as the
root file system.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined if the application wishes to use
the reduced functionality miniIMFS as the root filesystem. This reduced
version of the full IMFS does not include the capability to mount other
file system types, but it does support directories, device nodes, and
symbolic links.

@subheading NOTES:
The miniIMFS nodes and is smaller in executable code size than the full IMFS.

@c
@c === CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM ===
@c
@subsection Configure devFS as Root File System

@findex CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM

@table @b
@item CONSTANT:
@code{CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default. If no other root file system
configuration parameters are specified, the IMFS will be used as the
root file system.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined if the application wishes to
use the device-only filesytem as the root file system.

@subheading NOTES:
The device-only filesystem supports only device nodes and is smaller in
executable code size than the full IMFS and miniIMFS.

The devFS is comparable in functionality to the pseudo-filesystem name
space provided before RTEMS release 4.5.0.

@c
@c === CONFIGURE_APPLICATION_DISABLE_FILESYSTEM ===
@c
@subsection Disable File System Support

@findex CONFIGURE_APPLICATION_DISABLE_FILESYSTEM

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_DISABLE_FILESYSTEM}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default. If no other root file system
configuration parameters are specified, the IMFS will be used as the
root file system.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined if the application dose not
intend to use any kind of filesystem support. This include the device
infrastructure necessary to support @code{printf()}.

@subheading NOTES:
None.

@c
@c === Block Device Cache Configuration ===
@c
@section Block Device Cache Configuration

This section defines Block Device Cache (bdbuf) related configuration
parameters.

@c
@c === CONFIGURE_APPLICATION_NEEDS_LIBBLOCK ===
@c
@subsection Enable Block Device Cache

@findex CONFIGURE_APPLICATION_NEEDS_LIBBLOCK

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_LIBBLOCK}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
Provides a Block Device Cache configuration.

@subheading NOTES:
Each option of the Block Device Cache configuration can be explicitly set by
the user with the configuration options below.  The Block Device Cache is used
for example by the RFS and DOSFS file systems.

@c
@c === CONFIGURE_BDBUF_CACHE_MEMORY_SIZE ===
@c
@subsection Size of the Cache Memory

@findex CONFIGURE_BDBUF_CACHE_MEMORY_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_CACHE_MEMORY_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 32768 bytes.

@end table

@subheading DESCRIPTION:
Size of the cache memory in bytes.

@subheading NOTES:
None.

@c
@c === CONFIGURE_BDBUF_BUFFER_MIN_SIZE ===
@c
@subsection Minimum Size of a Buffer

@findex CONFIGURE_BDBUF_BUFFER_MIN_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_BUFFER_MIN_SIZE}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 512 bytes.

@end table

@subheading DESCRIPTION:
Defines the minimum size of a buffer in bytes.

@subheading NOTES:
None.

@c
@c === CONFIGURE_BDBUF_BUFFER_MAX_SIZE ===
@c
@subsection Maximum Size of a Buffer

@findex CONFIGURE_BDBUF_BUFFER_MAX_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_BUFFER_MAX_SIZE}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
It must be positive and an integral multiple of the buffer minimum size.

@item DEFAULT VALUE:
The default value is 4096 bytes.

@end table

@subheading DESCRIPTION:
Defines the maximum size of a buffer in bytes.

@subheading NOTES:
None.

@c
@c === CONFIGURE_SWAPOUT_SWAP_PERIOD ===
@c
@subsection Swapout Task Swap Period

@findex CONFIGURE_SWAPOUT_SWAP_PERIOD

@table @b
@item CONSTANT:
@code{CONFIGURE_SWAPOUT_SWAP_PERIOD}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 250 milliseconds.

@end table

@subheading DESCRIPTION:
Defines the swapout task swap period in milliseconds.

@subheading NOTES:
None.

@c
@c === CONFIGURE_SWAPOUT_BLOCK_HOLD ===
@c
@subsection Swapout Task Maximum Block Hold Time

@findex CONFIGURE_SWAPOUT_BLOCK_HOLD

@table @b
@item CONSTANT:
@code{CONFIGURE_SWAPOUT_BLOCK_HOLD}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 1000 milliseconds.

@end table

@subheading DESCRIPTION:
Defines the swapout task maximum block hold time in milliseconds.

@subheading NOTES:
None.

@c
@c === CONFIGURE_SWAPOUT_TASK_PRIORITY ===
@c
@subsection Swapout Task Priority

@findex CONFIGURE_SWAPOUT_TASK_PRIORITY

@table @b
@item CONSTANT:
@code{CONFIGURE_SWAPOUT_TASK_PRIORITY}

@item DATA TYPE:
Task priority (@code{rtems_task_priority}).

@item RANGE:
Valid task priority.

@item DEFAULT VALUE:
The default value is 15.

@end table

@subheading DESCRIPTION:
Defines the swapout task priority.

@subheading NOTES:
None.

@c
@c === CONFIGURE_BDBUF_MAX_READ_AHEAD_BLOCKS ===
@c
@subsection Maximum Blocks per Read-Ahead Request

@findex CONFIGURE_BDBUF_MAX_READ_AHEAD_BLOCKS

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_MAX_READ_AHEAD_BLOCKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
Defines the maximum blocks per read-ahead request.

@subheading NOTES:
A value of 0 disables the read-ahead task (default).  The read-ahead task will
issue speculative read transfers if a sequential access pattern is detected.
This can improve the performance on some systems.

@c
@c === CONFIGURE_BDBUF_MAX_WRITE_BLOCKS ===
@c
@subsection Maximum Blocks per Write Request

@findex CONFIGURE_BDBUF_MAX_WRITE_BLOCKS

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_MAX_WRITE_BLOCKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 16.

@end table

@subheading DESCRIPTION:
Defines the maximum blocks per write request.

@subheading NOTES:
None.

@c
@c === CONFIGURE_BDBUF_TASK_STACK_SIZE ===
@c
@subsection Task Stack Size of the Block Device Cache Tasks

@findex CONFIGURE_BDBUF_TASK_STACK_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_TASK_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is RTEMS_MINIMUM_STACK_SIZE.

@end table

@subheading DESCRIPTION:
Defines the task stack size of the Block Device Cache tasks in bytes.

@subheading NOTES:
None.

@c
@c === CONFIGURE_BDBUF_READ_AHEAD_TASK_PRIORITY ===
@c
@subsection Read-Ahead Task Priority

@findex CONFIGURE_BDBUF_READ_AHEAD_TASK_PRIORITY

@table @b
@item CONSTANT:
@code{CONFIGURE_BDBUF_READ_AHEAD_TASK_PRIORITY}

@item DATA TYPE:
Task priority (@code{rtems_task_priority}).

@item RANGE:
Valid task priority.

@item DEFAULT VALUE:
The default value is 15.

@end table

@subheading DESCRIPTION:
Defines the read-ahead task priority.

@subheading NOTES:
None.

@c
@c === CONFIGURE_SWAPOUT_WORKER_TASKS ===
@c
@subsection Swapout Worker Task Count

@findex CONFIGURE_SWAPOUT_WORKER_TASKS

@table @b
@item CONSTANT:
@code{CONFIGURE_SWAPOUT_WORKER_TASKS}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
Defines the swapout worker task count.

@subheading NOTES:
None.

@c
@c === CONFIGURE_SWAPOUT_WORKER_TASK_PRIORITY ===
@c
@subsection Swapout Worker Task Priority

@findex CONFIGURE_SWAPOUT_WORKER_TASK_PRIORITY

@table @b
@item CONSTANT:
@code{CONFIGURE_SWAPOUT_WORKER_TASK_PRIORITY}

@item DATA TYPE:
Task priority (@code{rtems_task_priority}).

@item RANGE:
Valid task priority.

@item DEFAULT VALUE:
The default value is 15.

@end table

@subheading DESCRIPTION:
Defines the swapout worker task priority.

@subheading NOTES:
None.

@c
@c === BSP Specific Settings ===
@c
@section BSP Specific Settings

This section describes BSP specific configuration settings used by
@code{<rtems/confdefs.h>}.  The BSP specific configuration settings are
defined in @code{<bsp.h>}.

@c
@c === Disable BSP Settings ===
@c
@subsection Disable BSP Configuration Settings

@findex CONFIGURE_DISABLE_BSP_SETTINGS

@table @b
@item CONSTANT:
@code{CONFIGURE_DISABLE_BSP_SETTINGS}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
All BSP specific configuration settings can be disabled by the application
with the @code{CONFIGURE_DISABLE_BSP_SETTINGS} option.

@subheading NOTES:
None.

@c
@c === CONFIGURE_MALLOC_BSP_SUPPORTS_SBRK ===
@c
@subsection Specify BSP Supports sbrk()

@findex CONFIGURE_MALLOC_BSP_SUPPORTS_SBRK

@table @b
@item CONSTANT:
@code{CONFIGURE_MALLOC_BSP_SUPPORTS_SBRK}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
This configuration parameter is defined by a BSP to indicate that it
does not allocate all available memory to the C Program Heap used by
the Malloc Family of routines.

If defined, when @code{malloc()} is unable to allocate memory, it will
call the BSP supplied @code{sbrk()} to obtain more memory.

@subheading NOTES:
This parameter should not be defined by the application. Only the BSP
knows how it allocates memory to the C Program Heap.

@c
@c === BSP_IDLE_TASK_BODY ===
@c
@subsection Specify BSP Specific Idle Task

@findex BSP_IDLE_TASK_BODY

@table @b
@item CONSTANT:
@code{BSP_IDLE_TASK_BODY}

@item DATA TYPE:
Function pointer.

@item RANGE:
Undefined or valid function pointer.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
If @code{BSP_IDLE_TASK_BODY} is defined by the BSP and
@code{CONFIGURE_IDLE_TASK_BODY} is not defined by the application,
then this BSP specific idle task body will be used.

@subheading NOTES:
As it has knowledge of the specific CPU model, system controller logic,
and peripheral buses, a BSP specific IDLE task may be capable of turning
components off to save power during extended periods of no task activity

@c
@c === BSP_IDLE_TASK_STACK_SIZE ===
@c
@subsection Specify BSP Suggested Value for IDLE Task Stack Size

@findex BSP_IDLE_TASK_STACK_SIZE

@table @b
@item CONSTANT:
@code{BSP_IDLE_TASK_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
If @code{BSP_IDLE_TASK_STACK_SIZE} is defined by the BSP and
@code{CONFIGURE_IDLE_TASK_STACK_SIZE} is not defined by the application,
then this BSP suggested idle task stack size will be used.


@subheading NOTES:
The order of precedence for configuring the IDLE task stack size is:

@itemize @bullet
@item RTEMS default minimum stack size.
@item If defined, then @code{CONFIGURE_MINIMUM_TASK_STACK_SIZE}.
@item If defined, then the BSP specific @code{BSP_IDLE_TASK_SIZE}.
@item If defined, then the application specified
@code{CONFIGURE_IDLE_TASK_SIZE}.
@end itemize

@c XXX - add cross references to other related values.

@c
@c === BSP_INITIAL_EXTENSION ===
@c
@subsection Specify BSP Specific User Extensions

@findex BSP_INITIAL_EXTENSION

@table @b
@item CONSTANT:
@code{BSP_INITIAL_EXTENSION}

@item DATA TYPE:
List of user extension initializers (@code{rtems_extensions_table}).

@item RANGE:
Undefined or a list of user extension initializers.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
If @code{BSP_INITIAL_EXTENSION} is defined by the BSP, then this BSP
specific initial extension will be placed as the last entry in the initial
extension table.

@subheading NOTES:
None.

@c
@c === BSP_INTERRUPT_STACK_SIZE ===
@c
@subsection Specifying BSP Specific Interrupt Stack Size

@findex BSP_INTERRUPT_STACK_SIZE

@table @b
@item CONSTANT:
@code{BSP_INTERRUPT_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
If @code{BSP_INTERRUPT_STACK_SIZE} is defined by the BSP and
@code{CONFIGURE_INTERRUPT_STACK_SIZE} is not defined by the application,
then this BSP specific interrupt stack size will be used.

@subheading NOTES:
None.

@c
@c === BSP_MAXIMUM_DEVICES ===
@c
@subsection Specifying BSP Specific Maximum Devices

@findex BSP_MAXIMUM_DEVICES

@table @b
@item CONSTANT:
@code{BSP_MAXIMUM_DEVICES}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
If @code{BSP_MAXIMUM_DEVICES} is defined by the BSP and
@code{CONFIGURE_MAXIMUM_DEVICES} is not defined by the application,
then this BSP specific maximum device count will be used.

@subheading NOTES:
This option is specific to the device file system (devFS) and should not be
confused with the @code{CONFIGURE_MAXIMUM_DRIVERS} option.  This parameter only
impacts the devFS and thus is only used by @code{<rtems/confdefs.h>} when
@code{CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM} is specified.

@c
@c === BSP_ZERO_WORKSPACE_AUTOMATICALLY ===
@c
@subsection BSP Recommends RTEMS Workspace be Cleared

@findex BSP_ZERO_WORKSPACE_AUTOMATICALLY

@table @b
@item CONSTANT:
@code{BSP_ZERO_WORKSPACE_AUTOMATICALLY}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
If @code{BSP_ZERO_WORKSPACE_AUTOMATICALLY} is defined by the BSP and
@code{CONFIGURE_ZERO_WORKSPACE_AUTOMATICALLY} is not defined by the
application, then the workspace will be zeroed automatically.

@subheading NOTES:
Zeroing memory can add significantly to system boot time. It is not
necessary for RTEMS but is often assumed by support libraries.

@c
@c === CONFIGURE_BSP_PREREQUISITE_DRIVERS ===
@c
@subsection Specify BSP Prerequisite Drivers

@findex CONFIGURE_BSP_PREREQUISITE_DRIVERS

@table @b
@item CONSTANT:
@code{CONFIGURE_BSP_PREREQUISITE_DRIVERS}

@item DATA TYPE:
List of device driver initializers (@code{rtems_driver_address_table}).

@item RANGE:
Undefined or array of device drivers.

@item DEFAULT VALUE:
This option is BSP specific.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_BSP_PREREQUISITE_DRIVERS} is defined if the BSP has device
drivers it needs to include in the Device Driver Table.  This should be
defined to the set of device driver entries that will be placed in the
table at the @b{FRONT} of the Device Driver Table and initialized before
any other drivers @b{INCLUDING} any application prerequisite drivers.

@subheading NOTES:
@code{CONFIGURE_BSP_PREREQUISITE_DRIVERS} is typically used by BSPs
to configure common infrastructure such as bus controllers or probe
for devices.


@c
@c === Idle Task Configuration ===
@c
@section Idle Task Configuration

This section defines the IDLE task related configuration parameters
supported by @code{<rtems/confdefs.h>}.

@c
@c === CONFIGURE_IDLE_TASK_BODY ===
@c
@subsection Specify Application Specific Idle Task Body

@findex CONFIGURE_IDLE_TASK_BODY

@table @b
@item CONSTANT:
@code{CONFIGURE_IDLE_TASK_BODY}

@item DATA TYPE:
Function pointer.

@item RANGE:
Undefined or valid function pointer.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_IDLE_TASK_BODY} is set to the function name corresponding
to the application specific IDLE thread body.  If not specified, the
BSP or RTEMS default IDLE thread body will be used.

@subheading NOTES:
None.

@c
@c === CONFIGURE_IDLE_TASK_STACK_SIZE ===
@c
@subsection Specify Idle Task Stack Size

@findex CONFIGURE_IDLE_TASK_STACK_SIZE

@table @b
@item CONSTANT:
@code{CONFIGURE_IDLE_TASK_STACK_SIZE}

@item DATA TYPE:
Unsigned integer (@code{size_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
The default value is RTEMS_MINIMUM_STACK_SIZE.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_IDLE_TASK_STACK_SIZE} is set to the
desired stack size for the IDLE task.

@subheading NOTES:
None.

@c
@c === CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION ===
@c
@subsection Specify Idle Task Performs Application Initialization

@findex CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION

@table @b
@item CONSTANT:
@code{CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default, the user is assumed
to provide one or more initialization tasks.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_IDLE_TASK_INITIALIZES_APPLICATION} is set to
indicate that the user has configured @b{NO} user initialization tasks
or threads and that the user provided IDLE task will perform application
initialization and then transform itself into an IDLE task.

@subheading NOTES:
If you use this option be careful, the user IDLE task @b{CANNOT} block
at all during the initialization sequence.  Further, once application
initialization is complete, it must make itself preemptible and enter
an IDLE body loop.

The IDLE task must run at the lowest priority of all tasks in the system.

@c
@c === Scheduler Algorithm Configuration ===
@c
@section Scheduler Algorithm Configuration

This section defines the configuration parameters related to selecting a
scheduling algorithm for an application.  For the schedulers built into
RTEMS, the configuration is straightforward.  All that is required is
to define the configuration macro which specifies which scheduler you
want for in your application.  The currently available schedulers are:

The pluggable scheduler interface also enables the user to provide their
own scheduling algorithm.  If you choose to do this, you must define
multiple configuration macros.

@c
@c === CONFIGURE_SCHEDULER_PRIORITY ===
@c
@subsection Use Deterministic Priority Scheduler

@findex CONFIGURE_SCHEDULER_PRIORITY

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_PRIORITY}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is defined by default.
This is the default scheduler and specifying this
configuration parameter is redundant.

@end table

@subheading DESCRIPTION:
The Deterministic Priority Scheduler is the default scheduler in RTEMS
for single core applications and is designed for predictable performance
under the highest loads.  It can block or unblock a thread in a constant
amount of time.  This scheduler requires a variable amount of memory
based upon the number of priorities configured in the system.

@subheading NOTES:
This scheduler may be explicitly selected by defining
@code{CONFIGURE_SCHEDULER_PRIORITY} although this is equivalent to the
default behavior.

@c
@c === CONFIGURE_SCHEDULER_SIMPLE ===
@c
@subsection Use Simple Priority Scheduler

@findex CONFIGURE_SCHEDULER_SIMPLE

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_SIMPLE}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
When defined, the Simple Priority Scheduler is used at the thread
scheduling algorithm. This is an alternative scheduler in RTEMS.
It is designed to provide the same task scheduling behaviour as the
Deterministic Priority Scheduler while being simpler in implementation
and uses less memory for data management.  It maintains a single sorted
list of all ready threads.  Thus blocking or unblocking a thread is not
a constant time operation with this scheduler.

This scheduler may be explicitly selected by defining
@code{CONFIGURE_SCHEDULER_SIMPLE}.

@subheading NOTES:
This scheduler is appropriate for use in small systems where RAM is limited.

@c
@c === CONFIGURE_SCHEDULER_EDF ===
@c
@subsection Use Earliest Deadline First Scheduler

@findex CONFIGURE_SCHEDULER_EDF

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_EDF}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
The Earliest Deadline First Scheduler (EDF) is an alternative scheduler in
RTEMS for single core applications. The EDF schedules tasks with dynamic
priorities equal to deadlines. The deadlines are declared using only
Rate Monotonic manager which handles periodic behavior.  Period is always
equal to deadline. If a task does not have any deadline declared or the
deadline is cancelled, the task is considered a background task which is
scheduled in case no deadline-driven tasks are ready to run.  Moreover,
multiple background tasks are scheduled according their priority assigned
upon initialization. All ready tasks reside in a single ready queue.

This scheduler may be explicitly selected by defining
@code{CONFIGURE_SCHEDULER_EDF}.

@subheading NOTES:
None.


@c
@c === CONFIGURE_SCHEDULER_CBS ===
@c
@subsection Use Constant Bandwidth Server Scheduler

@findex CONFIGURE_SCHEDULER_CBS

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_CBS}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
The Constant Bandwidth Server Scheduler (CBS) is an alternative scheduler
in RTEMS for single core applications. The CBS is a budget aware extension
of EDF scheduler. The goal of this scheduler is to ensure temporal
isolation of tasks. The CBS is equipped with a set of additional rules
and provides with an extensive API.

This scheduler may be explicitly selected by defining
@code{CONFIGURE_SCHEDULER_CBS}.
@c XXX - add cross reference to API chapter

@subheading NOTES:
None.

@c
@c === CONFIGURE_SCHEDULER_PRIORITY_SMP ===
@c
@subsection Use Deterministic Priority SMP Scheduler

@findex CONFIGURE_SCHEDULER_PRIORITY_SMP

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_PRIORITY_SMP}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
The Deterministic Priority SMP Scheduler is derived from the Deterministic
Priority Scheduler but is capable of scheduling threads across multiple
processors.

In a configuration with SMP enabled at configure time, it may be
explicitly selected by defining @code{CONFIGURE_SCHEDULER_PRIORITY_SMP}.

@subheading NOTES:
This scheduler is only available when RTEMS is configured with SMP
support enabled.

This scheduler is currently the default in SMP configurations and is
only selected when @code{CONFIGURE_SMP_APPLICATION} is defined.

@c
@c === CONFIGURE_SCHEDULER_SIMPLE_SMP ===
@c
@subsection Use Simple SMP Priority Scheduler

@findex CONFIGURE_SCHEDULER_SIMPLE_SMP

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_SIMPLE_SMP}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
The Simple SMP Priority Scheduler is derived from the Simple Priority
Scheduler but is capable of scheduling threads across multiple cores.
It is designed to provide the same task scheduling behaviour as the
Deterministic Priority Scheduler while distributing threads across
multiple cores.  Being based upon the Simple Priority Scheduler, it also
maintains a single sorted list of all ready threads.  Thus blocking or
unblocking a thread is not a constant time operation with this scheduler.

In addition, when allocating threads to cores, the algorithm is not
constant time. This algorithm was not designed with efficiency as a
primary design goal.  Its primary design goal was to provide an SMP-aware
scheduling algorithm that is simple to understand.

In a configuration with SMP enabled at configure time, it may be
explicitly selected by defining @code{CONFIGURE_SCHEDULER_SIMPLE_SMP}.

@subheading NOTES:
This scheduler is only available when RTEMS is configured with SMP
support enabled.

@c
@c === Configuring a User Scheduler ===
@c
@subsection Configuring a User Provided Scheduler

@findex CONFIGURE_SCHEDULER_USER

@table @b
@item CONSTANT:
@code{CONFIGURE_SCHEDULER_USER}

@item DATA TYPE:
Entry points for scheduler

@item RANGE:
Undefined or scheduler entry set

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
RTEMS allows the application to provide its own task/thread
scheduling algorithm. In order to do this, one must define
@code{CONFIGURE_SCHEDULER_USER} to indicate the application provides its
own scheduling algorithm. If @code{CONFIGURE_SCHEDULER_USER} is defined
then the following additional macros must be defined:

@itemize @bullet
@item @code{CONFIGURE_MEMORY_FOR_SCHEDULER} must be defined with the
amount of memory required as a base amount for the scheduler.

@item @code{CONFIGURE_MEMORY_PER_TASK_FOR_SCHEDULER(_tasks)} must be
defined as a formula which computes the amount of memory required based
upon the number of tasks configured.

@end itemize

@subheading NOTES:
At this time, the mechanics and requirements for writing a
new scheduler are evolving and not fully documented.  It is
recommended that you look at the existing Deterministic Priority
Scheduler in @code{cpukit/score/src/schedulerpriority*.c} for
guidance.  For guidance on the configuration macros, please examine
@code{cpukit/sapi/include/confdefs.h} for how these are defined for the
Deterministic Priority Scheduler.

@c
@c === SMP Specific Configuration Parameters ===
@c
@section SMP Specific Configuration Parameters

When RTEMS is configured to support SMP target systems, there are other
configuration parameters which apply.

@c XXX - add --enable-smp

@c
@c === CONFIGURE_SMP_APPLICATION ===
@c
@subsection Specify Application Uses Multiple Cores (is SMP)

@findex CONFIGURE_SMP_APPLICATION

@table @b
@item CONSTANT:
@code{CONFIGURE_SMP_APPLICATION}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
The default value is 1, (if CONFIGURE_SMP_APPLICATION is defined).

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_SMP_APPLICATION} must be defined if the application is
to make use of multiple CPU cores in an SMP target system.

@subheading NOTES:
None.

@c
@c === CONFIGURE_SMP_MAXIMUM_PROCESSORS ===
@c
@subsection Specify Maximum Processors in SMP System

@findex CONFIGURE_SMP_MAXIMUM_PROCESSORS

@table @b
@item CONSTANT:
@code{CONFIGURE_SMP_MAXIMUM_PROCESSORS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
The default value is 1, (if CONFIGURE_SMP_APPLICATION is defined).

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_SMP_MAXIMUM_PROCESSORS} must be set to the number of
CPU cores in the SMP configuration.

@subheading NOTES:
If there are more cores available than configured, the rest will be
ignored.

@c
@c === Device Driver Table ===
@c
@section Device Driver Table

This section defines the configuration parameters related
to the automatic generation of a Device Driver Table.  As
@code{<rtems/confdefs.h>} only is aware of a small set of
standard device drivers, the generated Device Driver
Table is suitable for simple applications with no
custom device drivers.

Note that network device drivers are not configured in the Device Driver Table.

@c
@c === CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE ===
@c
@subsection Specifying Application Defined Device Driver Table

@findex CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE}

@item DATA TYPE:
List of device driver initializers (@code{rtems_driver_address_table}).

@item RANGE:
Undefined or array of device drivers.

@item DEFAULT VALUE:
This is not defined by default, indicating the @code{<rtems/confdefs.h>}
is providing the device driver table.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_HAS_OWN_DEVICE_DRIVER_TABLE} is defined if the application
wishes to provide their own Device Driver Table.

The table must be an array of @code{rtems_driver_address_table} entries
named @code{Device_drivers}.

@subheading NOTES:
It is expected that there the application would only rarely need to do this.

@c
@c === CONFIGURE_MAXIMUM_DRIVERS ===
@c
@subsection Specifying the Maximum Number of Device Drivers

@findex CONFIGURE_MAXIMUM_DRIVERS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_DRIVERS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
This is computed by default, and is set to the number of device drivers
configured using the @code{CONFIGURE_APPLICATIONS_NEEDS_XXX_DRIVER}
configuration parameters.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_DRIVERS} is defined as the number of device
drivers per node.

@subheading NOTES:
If the application will dynamically install device drivers, then this
configuration parameter must be larger than the number of statically
configured device drivers. Drivers configured using the
@code{CONFIGURE_APPLICATIONS_NEEDS_XXX_DRIVER} configuration parameters
are statically installed.

@c
@c === CONFIGURE_MAXIMUM_DEVICES ===
@c
@subsection Specifying Maximum Devices

@findex CONFIGURE_MAXIMUM_DEVICES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_DEVICES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
If @code{BSP_MAXIMUM_DEVICES} is defined, then the
default value is @code{BSP_MAXIMUM_DEVICES}, otherwise the default value is 4.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_DEVICES} is defined to the number of
individual devices that may be registered in the device file system (devFS).

@subheading NOTES:
This option is specific to the device file system (devFS) and should not be
confused with the @code{CONFIGURE_MAXIMUM_DRIVERS} option.  This parameter only
impacts the devFS and thus is only used by @code{<rtems/confdefs.h>} when
@code{CONFIGURE_USE_DEVFS_AS_BASE_FILESYSTEM} is specified.

@c
@c === CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER ===
@c
@subsection Enable Console Device Driver

@findex CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_CONSOLE_DRIVER} is defined if the
application wishes to include the Console Device Driver.

@subheading NOTES:
This device driver is responsible for providing standard input and output
using @i{/dev/console}.

BSPs should be constructed in a manner that allows @code{printk()}
to work properly without the need for the console driver to be configured.

@c
@c === CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER ===
@c
@subsection Enable Clock Driver

@findex CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_CLOCK_DRIVER} is defined if the
application wishes to include the Clock Device Driver.

@subheading NOTES:
This device driver is responsible for providing a regular
interrupt which invokes the @code{rtems_clock_tick} directive.

If neither the Clock Driver not Benchmark Timer is enabled and
the configuration parameter
@code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER} is not defined,
then a compile time error will occur.

@c
@c === CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER ===
@c
@subsection Enable the Benchmark Timer Driver

@findex CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_TIMER_DRIVER} is defined if the
application wishes to include the Timer Driver.  This device driver is
used to benchmark execution times by the RTEMS Timing Test Suites.

@subheading NOTES:
If neither the Clock Driver not Benchmark Timer is enabled and
the configuration parameter
@code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER} is not defined,
then a compile time error will occur.

@c
@c === CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER ===
@c
@subsection Specify Clock and Benchmark Timer Drivers Are Not Needed

@findex CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_DOES_NOT_NEED_CLOCK_DRIVER} is defined when
the application does @b{NOT} want the Clock Device Driver and is @b{NOT}
using the Timer Driver.  The inclusion or exclusion of the Clock Driver
must be explicit in user applications.

@subheading NOTES:
This configuration parameter is intended to prevent the common user error
of using the Hello World example as the baseline for an application and
leaving out a clock tick source.

@c
@c === CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER ===
@c
@subsection Enable Real-Time Clock Driver

@findex CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_RTC_DRIVER} is defined if the
application wishes to include the Real-Time Clock Driver.

@subheading NOTES:
Most BSPs do not include support for a real-time clock. This is because
many boards do not include the required hardware.

If this is defined and the BSP does not have this device driver, then
the user will get a link time error for an undefined symbol.

@c
@c === CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER ===
@c
@subsection Enable the Watchdog Device Driver

@findex CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_WATCHDOG_DRIVER}
is defined if the application wishes to include the Watchdog Driver.

@subheading NOTES:
Most BSPs do not include support for a watchdog device driver. This is
because many boards do not include the required hardware.

If this is defined and the BSP does not have this device driver, then
the user will get a link time error for an undefined symbol.

@c
@c === CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER ===
@c
@subsection Enable the Graphics Frame Buffer Device Driver

@findex CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_FRAME_BUFFER_DRIVER} is defined
if the application wishes to include the BSP's Frame Buffer Device Driver.

@subheading NOTES:
Most BSPs do not include support for a Frame Buffer Device Driver. This is
because many boards do not include the required hardware.

If this is defined and the BSP does not have this device driver, then
the user will get a link time error for an undefined symbol.

@c
@c === CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER ===
@c
@subsection Enable Stub Device Driver

@findex CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_NEEDS_STUB_DRIVER} is defined if the
application wishes to include the Stub Device Driver.

@subheading NOTES:
This device driver simply provides entry points that return successful
and is primarily a test fixture. It is supported by all BSPs.

@c
@c === CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS ===
@c
@subsection Specify Application Prerequisite Device Drivers

@findex CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS}

@item DATA TYPE:
device driver entry structures

@item RANGE:
Undefined or set of device driver entry structures

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_PREREQUISITE_DRIVERS} is defined if the
application has device drivers it needs to include in the Device Driver
Table.  This should be defined to the set of device driver entries that
will be placed in the table at the @b{FRONT} of the Device Driver Table
and initialized before any other drivers @b{EXCEPT} any BSP prerequisite
drivers.

@subheading NOTES:
In some cases, it is used by System On Chip BSPs to support peripheral
buses beyond those normally found on the System On Chip. For example,
this is used by one RTEMS system which has implemented a SPARC/ERC32
based board with VMEBus. The VMEBus Controller initialization is performed
by a device driver configured via this configuration parameter.

@c XXX Add example

@c
@c === CONFIGURE_APPLICATION_EXTRA_DRIVERS ===
@c
@subsection Specify Extra Application Device Drivers

@findex CONFIGURE_APPLICATION_EXTRA_DRIVERS

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_EXTRA_DRIVERS}

@item DATA TYPE:
device driver entry structures

@item RANGE:
Undefined or set of device driver entry structures

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_APPLICATION_EXTRA_DRIVERS} is defined if the
application has device drivers it needs to include in the Device Driver
Table.  This should be defined to the set of device driver entries that
will be placed in the table at the @b{END} of the Device Driver Table.

@subheading NOTES:
None.

@c
@c === CONFIGURE_APPLICATION_NEEDS_NULL_DRIVER ===
@c
@subsection Enable /dev/null Device Driver

@findex CONFIGURE_APPLICATION_NEEDS_NULL_DRIVER
@cindex /dev/null

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_NULL_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
This configuration variable is specified to enable @i{/dev/null}
device driver.

@subheading NOTES:
This device driver is supported by all BSPs.

@c
@c === CONFIGURE_APPLICATION_NEEDS_ZERO_DRIVER ===
@c
@subsection Enable /dev/zero Device Driver

@findex CONFIGURE_APPLICATION_NEEDS_ZERO_DRIVER
@cindex /dev/zero

@table @b
@item CONSTANT:
@code{CONFIGURE_APPLICATION_NEEDS_ZERO_DRIVER}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
This configuration variable is specified to enable @i{/dev/zero}
device driver.

@subheading NOTES:
This device driver is supported by all BSPs.

@c
@c === Multiprocessing Configuration ===
@c
@section Multiprocessing Configuration

This section defines the multiprocessing related system configuration
parameters supported by @code{<rtems/confdefs.h>}.  They are only used
if the Multiprocessing Support (distinct from the SMP support) is enabled
at configure time using the @code{--enable-multiprocessing} option.

Additionally, this class of Configuration Constants are only applicable if
@code{CONFIGURE_MP_APPLICATION} is defined.

@c
@c === CONFIGURE_MP_APPLICATION ===
@c
@subsection Specify Application Will Use Multiprocessing

@findex CONFIGURE_MP_APPLICATION

@table @b
@item CONSTANT:
@code{CONFIGURE_MP_APPLICATION}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
This configuration parameter must be defined to indicate
that the application intends to be part of a multiprocessing
configuration. Additional configuration parameters are assumed to be
provided.

@subheading NOTES:
This has no impact unless RTEMS was configured and built using the
@code{--enable-multiprocessing} option.

@c
@c === CONFIGURE_MP_NODE_NUMBER ===
@c
@subsection Configure Node Number in Multiprocessor Configuration

@findex CONFIGURE_MP_NODE_NUMBER

@table @b
@item CONSTANT:
@code{CONFIGURE_MP_NODE_NUMBER}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is @code{NODE_NUMBER}, which is assumed to be
set by the compilation environment.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MP_NODE_NUMBER} is the node number of
this node in a multiprocessor system.

@subheading NOTES:
In the RTEMS Multiprocessing Test Suite, the node number is derived from
the Makefile variable @code{NODE_NUMBER}. The same code is compiled with
the @code{NODE_NUMBER} set to different values. The test programs behave
differently based upon their node number.


@c
@c === CONFIGURE_MP_MAXIMUM_NODES ===
@c
@subsection Configure Maximum Node in Multiprocessor Configuration

@findex CONFIGURE_MP_MAXIMUM_NODES

@table @b
@item CONSTANT:
@code{CONFIGURE_MP_MAXIMUM_NODES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 2.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MP_MAXIMUM_NODES} is the maximum number of nodes in a
multiprocessor system.

@subheading NOTES:
None.

@c
@c === CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS ===
@c
@subsection Configure Maximum Global Objects in Multiprocessor Configuration

@findex CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS

@table @b
@item CONSTANT:
@code{CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Positive.

@item DEFAULT VALUE:
The default value is 32.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS} is the maximum number of
concurrently active global objects in a multiprocessor system.

@subheading NOTES:
This value corresponds to the total number of objects which can be
created with the @code{RTEMS_GLOBAL} attribute.

@c
@c === CONFIGURE_MP_MAXIMUM_PROXIES ===
@c
@subsection Configure Maximum Proxies in Multiprocessor Configuration

@findex CONFIGURE_MP_MAXIMUM_PROXIES

@table @b
@item CONSTANT:
@code{CONFIGURE_MP_MAXIMUM_PROXIES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
The default value is 32.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MP_MAXIMUM_PROXIES} is the maximum number of concurrently
active thread/task proxies on this node in a multiprocessor system.

@subheading NOTES:
Since a proxy is used to represent a remote task/thread which is blocking on
this node. This configuration parameter reflects the maximum number of
remote tasks/threads which can be blocked on objects on this node.

@c XXX - add xref to proxy discussion in MP chapter

@c
@c === CONFIGURE_MP_MPCI_TABLE_POINTER ===
@c
@subsection Configure MPCI in Multiprocessor Configuration

@findex CONFIGURE_MP_MPCI_TABLE_POINTER

@table @b
@item CONSTANT:
@code{CONFIGURE_MP_MPCI_TABLE_POINTER}

@item DATA TYPE:
pointer to @code{rtems_mpci_table}

@item RANGE:
undefined or valid pointer

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MP_MPCI_TABLE_POINTER} is the pointer to the
MPCI Configuration Table.  The default value of this field is
@code{&MPCI_table}.

@subheading NOTES:
RTEMS provides a Shared Memory MPCI Device Driver which can be used on
any Multiprocessor System assuming the BSP provides the proper set of
supporting methods.

@c
@c === CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE ===
@c
@subsection Do Not Generate Multiprocessor Configuration Table

@findex CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE

@table @b
@item CONSTANT:
@code{CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_HAS_OWN_MULTIPROCESSING_TABLE} is defined if the
application wishes to provide their own Multiprocessing Configuration
Table.  The generated table is named @code{Multiprocessing_configuration}.

@subheading NOTES:
This is a configuration parameter which is very unlikely to be used by
an application. If you find yourself wanting to use it in an application,
please reconsider and discuss this on the RTEMS Users mailing list.

@c
@c === Ada Tasks ===
@c
@section Ada Tasks

This section defines the system configuration parameters supported
by @code{<rtems/confdefs.h>} related to configuring RTEMS to support
a task using Ada tasking with GNAT/RTEMS.

These configuration parameters are only available when RTEMS is built with
the @code{--enable-ada} configure option and the application specifies
@code{CONFIGURE_GNAT_RTEMS}.

Additionally RTEMS includes an Ada language binding to the Classic
API which has a test suite. This test suite is enabled only when
@code{--enable-tests} and @code{--enable-expada} are specified on the
configure command.

@c
@c === CONFIGURE_GNAT_RTEMS ===
@c
@subsection Specify Application Includes Ada Code

@findex CONFIGURE_GNAT_RTEMS

@table @b
@item CONSTANT:
@code{CONFIGURE_GNAT_RTEMS}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_GNAT_RTEMS} is defined to inform RTEMS that the GNAT
Ada run-time is to be used by the application.

@subheading NOTES:
This configuration parameter is critical as it makes
@code{<rtems/confdefs.h>} configure the resources (POSIX API Threads,
Mutexes, Condition Variables, and Keys) used implicitly by the GNAT
run-time.

@c
@c === CONFIGURE_MAXIMUM_ADA_TASKS ===
@c
@subsection Specify the Maximum Number of Ada Tasks.

@findex CONFIGURE_MAXIMUM_ADA_TASKS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_ADA_TASKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Undefined or positive.

@item DEFAULT VALUE:
If @code{CONFIGURE_GNAT_RTEMS} is defined, then the
default value is 20, otherwise the default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_ADA_TASKS} is the number of Ada tasks that can
be concurrently active in the system.

@subheading NOTES:
None.

@c
@c === CONFIGURE_MAXIMUM_FAKE_ADA_TASKS ===
@c
@subsection Specify the Maximum Fake Ada Tasks

@findex CONFIGURE_MAXIMUM_FAKE_ADA_TASKS

@table @b
@item CONSTANT:
@findex @code{CONFIGURE_MAXIMUM_FAKE_ADA_TASKS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 0.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_FAKE_ADA_TASKS} is the number of @i{fake} Ada tasks
that can be concurrently active in the system.  A @i{fake} Ada task is
a non-Ada task that makes calls back into Ada code and thus implicitly
uses the Ada run-time.

@subheading NOTES:
None.

@c
@c === Go Tasks ===
@c
@section Go Tasks

@c
@c === CONFIGURE_ENABLE_GO ===
@c
@subsection Specify Application Includes Go Code

@findex CONFIGURE_ENABLE_GO

@table @b
@item CONSTANT:
@code{CONFIGURE_ENABLE_GO}

@item DATA TYPE:
Boolean feature macro.

@item RANGE:
Defined or undefined.

@item DEFAULT VALUE:
This is not defined by default.

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_ENABLE_GO} is defined to inform RTEMS that the Go
run-time is to be used by the application.

@subheading NOTES:
The Go language support is experimental

@c
@c === CONFIGURE_MAXIMUM_GOROUTINES ===
@c
@subsection Specify the maximum number of Go routines

@findex CONFIGURE_MAXIMUM_GOROUTINES

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_GOROUTINES}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 400

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_GOROUTINES} is defined to specify the maximum number of
Go routines.

@subheading NOTES:
The Go language support is experimental

@c
@c === CONFIGURE_MAXIMUM_GO_CHANNELS ===
@c
@subsection Specify the maximum number of Go Channels

@findex CONFIGURE_MAXIMUM_GO_CHANNELS

@table @b
@item CONSTANT:
@code{CONFIGURE_MAXIMUM_GO_CHANNELS}

@item DATA TYPE:
Unsigned integer (@code{uint32_t}).

@item RANGE:
Zero or positive.

@item DEFAULT VALUE:
The default value is 500

@end table

@subheading DESCRIPTION:
@code{CONFIGURE_MAXIMUM_GO_CHANNELS} is defined to specify the maximum number
of Go channels.

@subheading NOTES:
The Go language support is experimental

@c
@c === Configuration Data Structures ===
@c
@section Configuration Data Structures

It is recommended that applications be configured using
@code{<rtems/confdefs.h>} as it is simpler and insulates applications
from changes in the underlying data structures.  However, it is sometimes
important to understand the data structures that are automatically filled
in by the configuration parameters.  This section describes the primary
configuration data structures.

If the user wishes to see the details of a particular data structure,
they are are advised to look at the source code. After all, that is one
of the advantages of RTEMS.
